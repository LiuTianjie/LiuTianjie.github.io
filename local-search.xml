<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>近世代数及其应用</title>
    <link href="/2020/09/24/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <url>/2020/09/24/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>又开始上学了，近世代数总结一波，随堂更新~</p><a id="more"></a><h2 id="近世代数及其应用"><a href="#近世代数及其应用" class="headerlink" title="近世代数及其应用"></a>近世代数及其应用</h2><h2 id="9-16-9-23-预备知识"><a href="#9-16-9-23-预备知识" class="headerlink" title="9.16 - 9.23 预备知识"></a>9.16 - 9.23 预备知识</h2><ul><li><p>摩根律</p><ul><li>$\overline{A\cup  B} = \overline{A}\cap \overline{B}$</li><li>$\overline{A\cap  B} = \overline{A}\cup \overline{B}$</li><li>推广到$n$个集合：$\begin{matrix}\overline{A_1\cup{A_2}…\cup{A_n}} = \overline{A_1}\cap\overline{A_2}…\overline{\cap{A_n}} \ \overline{A_1\cap{A_2}…\cap{A_n}} = \overline{A_1}\cup\overline{A_2}…\overline{\cup{A_n}} \end{matrix}$</li></ul></li><li><p>容斥定理（用于计数）</p><ul><li>$|A\cup B\cup C| = |A|+|B|+|C|-|A\cap B|-|A\cap C|-|B\cap C|+|A\cap B\cap C|$</li><li>推广到$n$个集合：$|A_1\cup A_2\cup … \cup A_n|=\sum_{1}^{n}|A_i|-\sum_{1\leqslant i\leqslant j}^{n}|A_i\cap A_j|+\sum_{1\leqslant i\leqslant j\leqslant k}^{n}|A_i\cap A_j\cap A_k|\-…+(-1)^{n-1}|A_1\cap A_2\cap …\cap A_n|$</li><li>另一种形式：$|\overline{A_1}\cap \overline{A}_2\cap…\cap \overline{A_n}|=|\overline{A_1\cup A_2\cup …\cup A_n}|=N-|A_1\cup A_2\cup …\cup A_n|$</li></ul><blockquote><p>例题1：500以内能被3或5整除的数的个数？</p><p>解：设集合A为500以内能被3整除的数的集合，</p><p>设集合B为500以内能被5整除的数的集合。则题目要求解的是$|A\cup B|$</p><p>$∴|A\cup B| = |A|+|B|-|A\cap B| = \left \lfloor \frac{500}{3} \right \rfloor+\left \lfloor \frac{500}{5} \right \rfloor+ \left \lfloor \frac{500}{3*5} \right \rfloor=233$</p><p>例题2：求由$a,b,c,d$个字母组成的$n$位字符串中，$a,b,c$各至少出现1次的字符串的个数？</p><p>解：设集合A为不包含字母$a$的n位字符串的集合，</p><p>设集合B为不包含字母$b$的n位字符串的集合，</p><p>设集合C为不包含字母$c$的n位字符串的集合，则题目要求解的是：$|\overline{A}\cap\overline{B}\cap\overline{C}|$</p><p>$；∴|\overline{A}\cap\overline{B}\cap\overline{C}|=|\overline{A\cup B \cup C}|=N-|A\cup B\cup C|\=N-(|A|+|B|+|C|-|A\cap B|-|A\cap C|-|B\cap C|+|A\cap B \cap C|)\=4^n-3^{n+1}+3·2^n-1$</p><p>例题3：</p><img src="https://images.nickname4th.vip/IMG_0819.jpg" srcset="/img/loading.gif" alt="IMG_0819" style="zoom: 25%;" /><p>解3.1：</p></blockquote></li><li><p>二元关系</p><blockquote><p>设$A,B$是两个集合，$A\times B$的子集$R$称为$A,B$间的一个<strong>二元关系</strong>.当$(a,b)\in R$时，称$a$与$b$据有关系$R$，记作$aRb$；当$(a,b)\notin R$时，称$a$与$b$据不有关系$R$，记作$aR’b$.</p></blockquote><ul><li><strong>自反性：$\forall a\in A\Rightarrow aRa.$</strong></li><li>反自反性</li><li><strong>对称性：$aRb\Rightarrow bRa $</strong></li><li>反对称性</li><li><strong>传递性：$aRb,\ bRc \Rightarrow aRc$</strong></li><li>满足自反性、对称性和传递性的关系成为==<strong>等价关系</strong>==，可记作$a\sim b$</li></ul></li><li><p>等价关系和集合的分类</p><ul><li><p>若对于$a,b∈A\ a\sim b，则[a]=[b]$；</p><blockquote><p>证明集合相等只需证明$[a]\subseteq [b]且[b]\subseteq [a]$</p></blockquote></li><li><p>若对于$a,b∈A\ a\nsim b{不等价}，则[a]\cap[b]=\phi $；</p><blockquote><p>反证法</p></blockquote></li><li><p>$A$能写成所有不同等价类的并，即$A=[a_1]\cup[a_2]\cup … \cup[a_n]…$。</p><blockquote><p>由上两个知两个等价类是相同的，或是不相交的</p><p>$\forall a\in A,a\in[a]$，∴$A$是所有不同等价类的并</p></blockquote></li></ul></li><li><p>映射：函数概念推广，两个集合的元素之间的关系</p><blockquote><p>$\forall a \in A$，如果通过法则$f$，存在唯一的$y \in D$，则$f$叫做$A到D$的一个映射；$y$叫做$x$在$f$之下的像，$x$叫做$y$在$f$下的一个原像;记作$f:A\rightarrow D,x \rightarrow y=f(x)$，当$A,D$是数集时，$f$就是函数。</p></blockquote><ul><li>单射：$\forall a,b\in A$，当$a \neq b$时，有$f(a)\neq f(b)$</li><li>满射：$f:A\rightarrow B,\forall b \in B, \exist a \in A$，使得$f(a)=b$</li><li>双射（一一映射）：既是单射，又是满射的映射</li></ul><blockquote><p>一个$A$到$A$之间的映射称作$A$的一个变换</p></blockquote><blockquote><p>设$A={a_1,a_2,…,a_n},B={b_1,b_2,…,b_m},#A=n,#B=m$.</p><ul><li>映射$f:A\rightarrow B$有$m^n$个</li><li>单射$f:A\rightarrow B$,当$n\leq m$时，有$m(m-1)(m-2)…(m-n+1)$个，当$n=m$时，双射有$m!$个</li><li>满射$f:A\rightarrow B$有$m^n-\binom{m}{1}(m-1)^n+\binom{m}{2}(m-1)^n-…+(-1)^{m-1}\binom{m}{m-1}$个，$m\leq n$（利用了容斥原理）</li></ul></blockquote></li><li><p>代数运算</p><ul><li>一个$A\times B$到$D$的映射叫做一个$A\times B$到$D$的代数运算，记作$A \circ B$</li><li>若$\circ$一个$A \times A$到$A$的代数运算，则说集合$A$对于$\circ$是封闭的，$\circ$是$A$上的二元运算</li></ul></li><li><p>同态与同构</p><blockquote><p>$\phi:A\rightarrow \bar{A},\circ$和$\bar{\circ}$分别是$A$和$\bar{A}$的代数运算，如果$\forall a,b\in A$，只要$a\rightarrow \bar{a},b\rightarrow \bar{b}$，就有$a\circ b\rightarrow\bar{a}\bar{\circ}\bar{b}$，则说$\phi$是$A$到$\bar{A}$的同态映射</p><p>另一种解释：</p><ul><li>设集合$A$的二元运算为$\circ$，则这个代数系统记为$(A,\circ)$</li></ul><p>设$(S,\circ),(T,\circ)$是两个代数系统，如果存在$S$到$T$的映射$f$，且保持运算$f(a\circ b)=f(a)*f(b),\forall a,b\in S$，则称$f$是$(S,\circ)$到$(T,\circ)$的同态映射</p><ul><li>如果$S \rightarrow T$的同态映射$f$是$S \rightarrow T$的双射，则称$f$为$S \rightarrow T$的同构映射</li></ul></blockquote></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>近世代数及其应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode中等题目分析（持续更新）</title>
    <link href="/2020/08/13/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <url>/2020/08/13/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>作为刷算法题目路上的一点心得。</p><a id="more"></a><h2 id="Leetcode中等题目分析（持续更新）"><a href="#Leetcode中等题目分析（持续更新）" class="headerlink" title="Leetcode中等题目分析（持续更新）"></a>Leetcode中等题目分析（持续更新）</h2><h3 id="1-No-8-字符串转整数"><a href="#1-No-8-字符串转整数" class="headerlink" title="1 No.8 字符串转整数"></a>1 No.8 字符串转整数</h3><p>请你来实现一个atio函数，使其能将字符串转换成整数。要求：</p><ul><li>首先丢弃字符串开头的空格</li><li>非空格的第一个字符串是正负号时，则将该符号与<code>后面</code>尽可能多<code>连续</code>的数字字符组合起来，形成一个有符号整数</li><li>非空格的第一个字符是数字时，直接将其与之后<code>连续</code>的数字字符组合起来，形成一个有符号整数</li><li>该字符串有效整数部分之后也可能存在多余的字符，应该被忽略</li><li>当不满足以上规则而无法进行转换时，返回0</li><li>返回整数的大小范围为32位有符号整数的范围</li></ul><h4 id="1-1-直接上手"><a href="#1-1-直接上手" class="headerlink" title="1.1 直接上手"></a>1.1 直接上手</h4><p>最简单的方法是直接开始编码，但是显然，会遇到很多麻烦，并且写出的代码具有非常多的<code>if-else</code>结构，十分臃肿，我在VS Code上测试了十余次，前后经过了一两个小时，才写出完整AC的代码，可以说是十分low了。</p><pre><code class="python">class Solution:    def myAtoi(self, str: str) -&gt; int:        res = &quot; &quot;        flag = True        strList = list(str.strip())        for i in range(len(strList)):            if strList[i] != &quot; &quot;:                for j in strList[i:]:                    if j == &quot; &quot;:                        break                    if (j == &quot;+&quot; or j == &quot;-&quot;) and flag:                        res += j                        flag = False                        continue                    elif j.isdigit():                        res += j                        flag = False                    else:                        break                break        try:            res = int(res)        except:            return 0        return max(-2**31, min(res, 2**31-1))</code></pre><p>其中<code>flag</code>用于标志<code>是否已经添加了正负号</code>，因为如果对符号进行统一的直接拼接处理，则会如果有多个正负号出现时程序出错的问题。（这其实是测试了多次，从测试用例观察出来的）</p><p>整个思路为：</p><ul><li>首先将字符串转换成列表，包括空格在内</li><li>进入第一个<code>for</code>循环，字符非空格时，进入第二个循环，循环从第一个非空字符开始，即<code>strList[i:]</code></li><li>非空字符后面再遇到空格时，结束循环</li><li>如果遇到正负号，则判断<code>flag</code>，仅在第一次出现时添加符号</li><li>如果遇到数字字符，则直接和<code>res</code>进行拼接</li><li>遇到其他字符，则结束循环</li><li>将<code>res</code>转换成整数，为了避免可能出现的问题如<code>res</code>为空等情况，使用<code>try-catch</code>语法将其包裹，如果出错直接返回0</li><li>最后判断<code>res</code>是否在32位有符号整数的范围内，根据条件返回整数</li></ul><p>算法的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code></p><p>可以看到整个流程十分复杂，并且绝不是一次想好就能编写出这样的代码，因此在面对这样的题目时，我们需要用另一种思路去更清晰的分析问题。</p><h4 id="1-2-有限状态机"><a href="#1-2-有限状态机" class="headerlink" title="1.2 有限状态机"></a>1.2 有限状态机</h4><p>通过简单分析，可以知道整个转换的流程主要有4种状态：</p><ul><li>初始状态，直到首个不为空格的字符之前，都处于这个状态</li><li>符号转换状态，在遇到符号时，处于这个状态</li><li>数字转换状态，在遇到数字字符时，出于这个状态</li><li>结束状态，即程序退出</li></ul><img src="http://images.nickname4th.vip/charTonum.png" srcset="/img/loading.gif" alt="charTonum" style="zoom:50%;" /><p>各状态之间的转换流程和其对应的表格如上图所示。根据状态转移图和表格，可以很方便的写出程序：</p><pre><code class="python">INT_MAX = 2 ** 31 - 1INT_MIN = -2 ** 31class Auto:    def __init__(self):        self.status = &#39;start&#39;        self.sign = 1        self.ans = 0        self.status_matrix = {            &#39;start&#39;: [&#39;start&#39;, &#39;change_number&#39;, &#39;signed&#39;, &#39;end&#39;],            &#39;signed&#39;: [&#39;end&#39;, &#39;change_number&#39;, &#39;end&#39;, &#39;end&#39;],            &#39;change_number&#39;: [&#39;end&#39;, &#39;change_number&#39;, &#39;end&#39;, &#39;end&#39;],            &#39;end&#39;: [&#39;end&#39;, &#39;end&#39;, &#39;end&#39;, &#39;end&#39;]        }    # 获取当前的状态    def get_status(self, c: str) -&gt; int:        if c.isspace():            return 0        elif c.isdigit():            return 1        elif c == &#39;+&#39; or c == &quot;-&quot;:            return 2        else:            return 3    # 处理当前字符    def get(self, c: str):        self.status = self.status_matrix[self.status][self.get_status(c)]        if self.status == &#39;change_number&#39;:            self.ans = self.ans*10 + int(c)            self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(                self.ans, -INT_MIN)        elif self.status == &quot;signed&quot;:            self.sign = 1 if c == &#39;+&#39; else -1class Solution:    def myAtoi(self, str: str) -&gt; int:        auto = Auto()        for c in str:            auto.get(c)        return auto.sign * auto.ans</code></pre><p>根据状态转移表创建<code>status_martix</code>字典，以每种状态为键，值依次为下一个字符出现时的转移状态，通过<code>get_status</code>方法处理并返回下一个状态，<code>get</code>处理符号和数字两种情况。</p><p>这样一来，整个程序的状态十分清晰，也无需再依靠苦苦的调试测试用例来写一堆臃肿的<code>if-else</code>代码，算法的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>虽然最后通过击败的人数不如前一种方法，但是这样的方式思考问题是值得借鉴的。</p><h2 id="2020-6-5更新"><a href="#2020-6-5更新" class="headerlink" title="==2020.6.5更新=="></a>==2020.6.5更新==</h2><h3 id="2-电话号码的字符组合"><a href="#2-电话号码的字符组合" class="headerlink" title="2 电话号码的字符组合"></a>2 电话号码的字符组合</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="http://images.nickname4th.vip/%E7%AE%97%E6%B3%952.png" srcset="/img/loading.gif" alt="算法2"></p><h4 id="2-1-使用循环"><a href="#2-1-使用循环" class="headerlink" title="2.1 使用循环"></a>2.1 使用循环</h4><p>很显然的可想到使用循环遍历来进行字母的组合：</p><ul><li>首先将数字-字母形成键值对，保存到字典中<pre><code class="python">      mapping = {&#39;2&#39;: &#39;abc&#39;, &#39;3&#39;: &#39;def&#39;, &#39;4&#39;: &#39;ghi&#39;, &#39;5&#39;: &#39;jkl&#39;,&#39;6&#39;: &#39;mno&#39;, &#39;7&#39;: &#39;pqrs&#39;, &#39;8&#39;: &#39;tuv&#39;, &#39;9&#39;: &#39;wxyz&#39;}</code></pre></li><li>遍历输入字符串，根据当前数字查找字典，再进行其间的排列组合<pre><code class="python"># 当仅有两个数字时ans=[]res=&#39;&#39;for i in mapping(digits[0]):  for j in mapping(digits[1]):      res =i+j      ans.append(res)return ans</code></pre>经过实际上手代码发现，循环的方式需要确定循环的次数，并且要手动编写循环体，所以转而使用递归。<h4 id="2-2-使用递归"><a href="#2-2-使用递归" class="headerlink" title="2.2 使用递归"></a>2.2 使用递归</h4><pre><code class="python">ans=[]Lists = [mapping[i] for i in str]def addLetter(items):  if len(items)==0:      return []  if len(items)==1:      return items[0]  now = items[-1]  p = addLetter(items[:-1])  return [s + c for s in p for c in now]</code></pre>这个<code>return</code>后的列表解析表达式等价于：<pre><code class="python">for s in p:  for c in now:      ans.append(s+c)return ans# 即for s in addLetter(items[:-1]):  for j in items[-1]:      ans.append(s+c)return ans</code></pre>其中，函数递归调用的过程体现在第一层<code>for</code>循环中，其中的<code>s</code>并不能直接获得，而是随着递归调用逐渐改变。</li></ul><h2 id="2020-6-7更新"><a href="#2020-6-7更新" class="headerlink" title="==2020.6.7更新=="></a>==2020.6.7更新==</h2><h3 id="3-删除链表的倒数第n个结点"><a href="#3-删除链表的倒数第n个结点" class="headerlink" title="3 删除链表的倒数第n个结点"></a>3 删除链表的倒数第n个结点</h3><p>给定一个链表，删除链表的倒数第n个结点，并返回链表结点的头结点。</p><p>链表的缺点就是查找元素不方便，要找到任何一个结点都必须遍历其之前的全部结点，所以一般的思路是：</p><ul><li>遍历链表，记录链表的大小<pre><code class="python">  count=0  while head:      count+=1      head = head.next</code></pre></li><li>利用循环，当遍历到倒数第n个节点的前一个结点时，删除节点<pre><code class="python">  start = head  for i in range(0,count):      if count-i == n-1:          start.next = start.next.next      start = start.next</code></pre>但是其实可以利用多个指针来进行，这样就无需事先遍历统计节点的个数了。</li><li>设定一个快指针<code>fast</code>，一个慢指针<code>slow</code>，指向头结点<code>head</code>，假设总共有<code>N</code>个结点，则倒数第<code>n</code>个结点的索引为<code>N-n-1</code></li><li>先将快指针<code>fast</code>向后移动<code>n</code>次， 指向结点索引为<code>n-1</code></li><li>然后将快指针<code>fast</code>移动到末尾，同时移动慢指针<code>slow</code>，当fast指向末尾结点时，慢指针指向结点索引为<code>N-n</code>，即倒数第<code>n</code>个结点的前一个结点</li><li>此时直接删除慢指针<code>slow</code>指向的结点的后一个结点即可<br>图示如下：<br><img src="http://images.nickname4th.vip/10.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9.png" srcset="/img/loading.gif" alt="10.删除链表倒数第n个结点"><pre><code class="python">class Solution:  def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:      fast = slow = head      for _ in range(n):          fast = fast.next      if not fast:          return head.next      while fast.next:          fast = fast.next          slow = slow.next      slow.next = slow.next.next      return head</code></pre><h2 id="2020-6-10更新"><a href="#2020-6-10更新" class="headerlink" title="==2020.6.10更新=="></a>==2020.6.10更新==</h2><h3 id="4-括号生成"><a href="#4-括号生成" class="headerlink" title="4 括号生成"></a>4 括号生成</h3>数字<code>n</code>代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。</li></ul><h4 id="4-1-回溯法（深度优先遍历）"><a href="#4-1-回溯法（深度优先遍历）" class="headerlink" title="4.1 回溯法（深度优先遍历）"></a>4.1 回溯法（深度优先遍历）</h4><p>首先想到的就是回溯法（深度优先遍历），由于其可以利用函数递归的方式，直接利用系统栈，而广度优先遍历往往需要我们自定义数据结构。<br>分析如下：</p><ul><li>当左括号的数量小于n时，可以生成子树</li><li>产生左子树时，仅判断左括号数量是否小于n</li><li>当产生右子树时，判断右括号数量是否小于左括号数量</li><li>整个树的节点数量等于2n时结束</li></ul><p>以<code>n=2</code>的情况为例，其树的生成情况如图所示：<br><img src="http://images.nickname4th.vip/qute.png" srcset="/img/loading.gif" alt="qute"></p><pre><code class="python">ans=[]def generateParenthesis(self, n: int) -&gt; List[str]:    def generate(Tree,L,R):        if len(Tree)==2*n:            ans.append(&#39;&#39;.join(Tree))            # 满足条件的组合进入后，返回到上一层函数            return        if L &lt; n:            Tree.append(&#39;(&#39;)            generate(Tree,L+1,R)            # 得到调用函数的返回时，出栈，回到父函数            Tree.pop()        if L &gt; R:            Tree.appned(&#39;)&#39;)            generate(Tree,L,R+1)            # 得到调用函数的返回时，出栈，回到父函数            Tree.pop()    generate([],0,0)    return ans</code></pre><h4 id="4-2-动态规划"><a href="#4-2-动态规划" class="headerlink" title="4.2 动态规划"></a>4.2 动态规划</h4><p>首先分析状态及其转移方程：</p><ul><li>状态<code>dp[i]</code>代表括号对数为<code>i</code>时的所有正确的组合数</li><li>状态<code>dp[i]</code>依赖于<code>dp[j]</code>和<code>dp[k]</code>，其中<code>j</code>和<code>k</code>满足<code>j+k=i-1</code>，事实上，<code>dp[i]</code>仅仅比<code>dp[j]</code>和<code>dp[k]</code>的组合多了一对括号<code>( )</code>,其位置关系为：<ul><li>从<code>dp[0]</code>开始，<code>dp[0]=[&quot;&quot;]</code></li><li><code>dp[j]</code>在<code>( )</code>内部，<code>dp[k]</code>在<code>( )</code>外部</li><li>即<code>dp[i] = &quot;(&quot; + dp[j] + &quot;)&quot; + dp[k]</code><pre><code class="python">class Solution:def generateParenthesis(self, n: int) -&gt; List[str]:  if n == 0:      return []  dp = [None for _ in range(n + 1)]  dp[0] = [&quot;&quot;]  for i in range(1, n + 1):      cur = []      for j in range(i):          left = dp[j]          right = dp[i - j - 1]          for s1 in left:              for s2 in right:                  cur.append(&quot;(&quot; + s1 + &quot;)&quot; + s2)      dp[i] = cur  return dp[n]</code></pre><h2 id="2020-8-13更新"><a href="#2020-8-13更新" class="headerlink" title="==2020.8.13更新=="></a>==2020.8.13更新==</h2>N数和，给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在N个元素 a,b,c,d,… ，使得 a + b + c + d +…的值与 target 相等？找出所有满足条件且不重复的四元组。<blockquote><p>对于2数、3数的情况，我们可以使用双指针，但是拓展到N个数的时候，我们采用回溯法会比较方便。</p></blockquote><pre><code class="javascript">function nSums(nums,target,N){let res = []nums.sort((a,b)=&gt;a-b)function dfs(nums,target,index,tmp,res){  if(tmp.length&lt;=N &amp;&amp; index &lt; nums.length){      if(target==0 &amp;&amp; tmp.length==n){          res.push(tmp)          return       }      else{          for(let i =index; i&lt;nums.length;i++){              tmp.push(nums[i])              dfs(nums,target - nums[i],i+1,tmp,res)              return          }      }  }  return}dfs(nums,target,0,[],res)return res}</code></pre>这里默认数组中不包含重复元素， 如果包含重复元素，需要进行剪枝处理，注意使用JavaScript语言，在进行深度优先遍历时不要忘记 <strong><code>return</code></strong></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unitimmer数据库设计</title>
    <link href="/2020/07/02/Unitimmer%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/07/02/Unitimmer%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>​    本文讲述我的开源项目<a href="https://github.com/LiuTianjie/unitimmer" target="_blank" rel="noopener">unitimmer</a>的数据库设计，我将从需求分析出发，设计各数据表的结构，并使用<code>Django</code>的<code>ORM</code>来定义数据模型，最终该项目的后端将从<code>Node.js</code>重构为<code>Django</code></p><a id="more"></a><h2 id="Unitimmers数据库设计"><a href="#Unitimmers数据库设计" class="headerlink" title="Unitimmers数据库设计"></a>Unitimmers数据库设计</h2><h3 id="1-数据表"><a href="#1-数据表" class="headerlink" title="1 数据表"></a>1 数据表</h3><ul><li><p>动态表</p><p>动态表存储所有用户发布的全部动态，包括动态的唯一id、用户名、头像、发布日期、文字内容、图片链接等信息，其中动态唯一id<code>msgID</code>作为主键，并且作为外键在点赞表中使用</p></li><li><p>用户表</p></li><li><p>点赞表</p></li><li><p>评论表</p><p>整个数据表设计完成时的E-R图为：</p></li></ul><img src="https://images.nickname4th.vip/unidb1.png" srcset="/img/loading.gif" alt="unidb" style="zoom:50%;" /><h3 id="和前端的联系"><a href="#和前端的联系" class="headerlink" title="和前端的联系"></a>和前端的联系</h3><ul><li><p>UI设计页面</p><img src="https://images.nickname4th.vip/dailyPage.png" srcset="/img/loading.gif" alt="dailyPage" style="zoom:50%;" /></li><li><p>数据字段的作用（以红色文字和箭头标出）</p><img src="https://images.nickname4th.vip/dailyUsage.png" srcset="/img/loading.gif" alt="dailyUsage" style="zoom:50%;" /><p>其中点赞信息由点赞用户和点赞总数组成，这两个字段没有在数据库中直接存储，而是需要经过查询动态获取。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript异步编程</title>
    <link href="/2020/05/25/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/05/25/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>总结了JavaScript异步编程的一些方式。</p><a id="more"></a><h2 id="JavaScript异步操作"><a href="#JavaScript异步操作" class="headerlink" title="JavaScript异步操作"></a>JavaScript异步操作</h2><p>在实际项目开发中，经常遇到网络请求、数据库操作等异步操作，由于这些操作需要耗费一定的时间，而JavaScript是一个单线程的语言，因此在执行异步操作时，其不进入主线程，而是加入一个任务队列，主线程继续执行同步任务，当异步任务执行完毕时，只需通知主线程即可。当异步操作指定了回调函数时，主线程将在其执行完毕时调用执行回调函数。</p><h3 id="1-模拟一个异步操作"><a href="#1-模拟一个异步操作" class="headerlink" title="1 模拟一个异步操作"></a>1 模拟一个异步操作</h3><pre><code class="javascript">let a = 0function set_a(val,time){  setTimeout(()=&gt;{    a = val  },time)}set_a(1,1000)console.log(a)//0</code></pre><p>在这里，setTimeout函数延时1000ms执行，是一个异步操作，简单分析一下代码执行过程：</p><ul><li>声明变量<code>a</code>，初始化其值为<code>0</code></li><li>定义函数<code>set_a( )</code></li><li>执行函数<code>set_a(1,1000)</code>，在<code>1000ms</code>后将<code>a</code>赋值为<code>1</code></li><li>将<code>set_a(1,1000)</code>加入异步任务队列并执行</li><li>执行<code>console.log(a)</code>，打印<code>a</code>的值为<code>0</code></li><li>约1s后，<code>set_a(1,1000)</code>执行完毕，此时<code>a</code>的值为<code>1</code></li></ul><h4 id="1-1-使用回调函数进行异步编程"><a href="#1-1-使用回调函数进行异步编程" class="headerlink" title="1.1 使用回调函数进行异步编程"></a>1.1 使用回调函数进行异步编程</h4><p>使用回调函数是最简单直接的方法，如这里我们想在a的值改变后再将其打印输出：</p><pre><code class="javascript">let a = 0function set_a(val, time, callback) {    setTimeout(() =&gt; {        a = val        callback(a)    }, time)}set_a(100, 1000, (a) =&gt; {    console.log(a)})//100</code></pre><p>回调函数的一大缺点是当有多个异步操作需要进行，并且其相互之间有依赖关系时，容易遇到<code>回调地狱</code>的问题。</p><h4 id="1-2-使用Promise"><a href="#1-2-使用Promise" class="headerlink" title="1.2 使用Promise"></a>1.2 使用Promise</h4><p>Promise让异步编程非常容易理解，也可以避免回调地狱的产生，同时也是ES6支持的一种方式。</p><pre><code class="javascript">function set_a(val, time) {    return new Promise(function (reslove, reject) {        setTimeout(() =&gt; {            a = val            reslove(a)        }, time)    })}set_a(100, 1000).then(() =&gt; console.log(a))//100</code></pre><p>当有多个异步操作需要进行时，可以通过在<code>.then</code>中return一个Promise对象来进行：</p><pre><code class="javascript">set_a(100, 1000).then(() =&gt; {    console.log(a)    return set_a(200, 500)}).then(() =&gt; console.log(a))//100//200</code></pre><p>虽然Promise避免了回调地狱，但是带来了<code>执行地狱</code>，即有多个异步操作需要进行时，仍然需要不断通过<code>.then</code>来调用。</p><h4 id="1-3-使用Generator"><a href="#1-3-使用Generator" class="headerlink" title="1.3 使用Generator"></a>1.3 使用Generator</h4><p>ES6中的Generator和Python的十分相似，其本质是一个函数，最大的特点是可以被<code>中断</code>，然后恢复执行。</p><p>定义一个简单的Generator函数：</p><pre><code class="javascript">function * gen(){  yield &quot;hello&quot;  return &quot;world&quot;}</code></pre><ul><li>在函数中定义了<code>x</code>个<code>yield</code>关键字，则函数具有<code>x+1</code>种状态（包含<code>return</code>）</li><li><code>yield</code>关键字不产生任何返回，只对其后面的表达式进行求值</li><li>通过<code>next()</code>方法继续执行程序</li><li><code>next()</code>方法可以接受一个参数，传递到Generator内部，利用这个特性来组织异步代码</li><li>更常见的情况是<code>yield</code>关键字后面接一个<code>Promise</code>对象</li></ul><pre><code class="javascript">list = [1, 2, 3, 4, 6, 3, 1]function* gen() {    for (let i of list) {        //延时设置为随机数，模拟实际的异步情况        yield set_a(val, Math.round(Math.random()) * 1000)    }}var g = gen()var r1 = g.next()r1.value.then(() =&gt; {    console.log(a1)    var r2 = g.next()    r2.value.then(() =&gt; console.log(a1))})//1//2</code></pre><ul><li>调用<code>next()</code>方法时，返回对象的<code>value</code>值就是<code>yield</code>语句的值，<code>done</code>属性用来标志Generator方法是否执行结束</li></ul><p>在执行for循环中的异步操作时，由于<code>next()</code>方法需要手动执行，因此可以通过递归调用来自动执行：</p><pre><code class="javascript">function promise_list(p) {    if (!p.done) {        p.value.then(() =&gt; {            console.log(a1)            promise_list(g.next())        })    }}promise_list(g.next())//1//2//3//4//6//3//1</code></pre><h4 id="1-4-async-await"><a href="#1-4-async-await" class="headerlink" title="1.4 async/await"></a>1.4 async/await</h4><p>async函数可以简单的看做带有自执行器的Generator函数。</p><pre><code class="javascript">async function async_set_a() {    await set_a(1, 1000).then(() =&gt; console.log(a))    await set_a(2, 200).then(() =&gt; console.log(a))}async_set_a()//在for循环中使用async/awaitlist = [1, 2, 3]async function set_list(list) {    for (let i of list) {        await set_a(i, 100)        console.log(a)    }}set_list(list)</code></pre><p>这里和1.2明显的区别就是不用再通过<code>.then</code>来嵌套调用，避免了<code>执行地狱</code></p><ul><li>async函数返回一个Promise对象，当在方法体中遇到异步操作时，会立即返回，随后不断<code>轮询</code>直到异步操作完成，随后再执行方法体内剩下的代码</li><li>await关键字必须位于async函数内部</li><li>await关键字后面必须跟一个Promise对象，如果不是，则使用resolve将其转换</li><li>await的结果即为Promis执行的结果，为<code>resolve</code>或<code>reject</code>的值</li><li>可以通过<code>Promise.all()</code>进行并行操作</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端实习面经</title>
    <link href="/2020/05/23/%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"/>
    <url>/2020/05/23/%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<p>刚出炉的面试凉经，哎<del>~</del>。</p><a id="more"></a><h2 id="字节跳动-amp-百词斩前端实习一面"><a href="#字节跳动-amp-百词斩前端实习一面" class="headerlink" title="字节跳动&amp;百词斩前端实习一面"></a>字节跳动&amp;百词斩前端实习一面</h2><p>自我感觉没有准备充足，算法了解较少，前端基础较薄弱。</p><p>面试官问的<code>问题</code>和你的<code>简历直接相关</code>，先看下简历：<img src="http://images.nickname4th.vip/简历.png" srcset="/img/loading.gif" alt="简历" style="zoom:50%;border:1px solid grey;" /></p><p>然后直接进入正题吧，写写面试官问的问题。</p><h2 id="1-字节跳动"><a href="#1-字节跳动" class="headerlink" title="1 字节跳动"></a>1 字节跳动</h2><h3 id="1-1-前端基础"><a href="#1-1-前端基础" class="headerlink" title="1.1 前端基础"></a>1.1 前端基础</h3><ul><li>Vue使用的版本？</li><li><code>v-for</code>,<code>v-if</code>实现的原理，模板编译的过程？</li><li>简单实现一个模板编译？</li><li>Vue的虚拟DOM有什么优点，了解其实现过程吗？</li><li>Node的express中间件工作的流程？</li><li>在开发中使用ES6还是ES5？二者的主要差异？</li><li>NoSQL和SQL类型数据库的优劣？</li><li><code>flex:1 1;</code>表示什么意思?</li><li>登录注册系统如何鉴权、保管登录态？</li><li>cookie一般用来做什么，除了cookie还有什么相关的东西可以实现类似的效果？</li><li>Http和Https的区别？</li><li>简单阐述一下ARP协议？</li><li>简单说一说DNS工作的流程？</li><li>Event.on的作用？</li><li>Webpack，bable了解多少？</li><li>类似微博主页的行列结构用css怎么实现？</li></ul><h3 id="1-2-算法相关"><a href="#1-2-算法相关" class="headerlink" title="1.2 算法相关"></a>1.2 算法相关</h3><ul><li>一道深度搜索递归的问题，参考<a href="https://leetcode-cn.com/problems/max-area-of-island/solution/" target="_blank" rel="noopener">leetcode—岛屿的最大面积</a></li><li>给定数组，三个数<code>a+b+c=k</code>的问题，参考<a href="https://leetcode-cn.com/problems/3sum/solution/" target="_blank" rel="noopener">leetcode——三数之和</a></li></ul><p>整个面试持续了50分钟，总的来说，我的前端基础显得还比较薄弱，偏向于应用而不是深入了解其原理，算法题难度在leetcode都算中等，但是由于我平时算法题刷的比较少，解决起来比较吃力。</p><h2 id="2-百词斩"><a href="#2-百词斩" class="headerlink" title="2 百词斩"></a>2 百词斩</h2><h3 id="2-1-笔试部分"><a href="#2-1-笔试部分" class="headerlink" title="2.1 笔试部分"></a>2.1 笔试部分</h3><p>笔试部分是三道算法题，我只记得其中两道。</p><h4 id="①-判断一个数是否是素数"><a href="#①-判断一个数是否是素数" class="headerlink" title="① 判断一个数是否是素数"></a>① 判断一个数是否是素数</h4><p>这道题说简单也十分简单，但是要往深处追究还是有很大的优化空间。</p><pre><code class="javascript">//判断素数function isPrime(n) {    if (n &lt; 2) {        return false    }    if (n == 2) {        return true    }    //这一步非必须，但是可以筛出所有偶数，减少计算量，n特别大的时候有效    if (n % 2 == 0) {        return false    }    for (let i = 2; i &lt; parseInt(Math.sqrt(n)) + 1; i++) {        if (n % i == 0) {            return false        }    }    return true}</code></pre><h4 id="③-26进制加法"><a href="#③-26进制加法" class="headerlink" title="③ 26进制加法"></a>③ 26进制加法</h4><p>我这里使用了python编程，很自然的想到26进制对应a~z的26个字母，使用<code>ord(&#39;a&#39;)</code>可以获取字母a对应的ASSIC值为97，其余的就直接遍历字符串每一位然后做乘加就行了。</p><p>通过率方面，第一题为68%+，第二题没做出来，第三题95%+，第二天收到HR通知说笔试通过了，然后收到了面试邀请。</p><h3 id="2-2-面试基本情况"><a href="#2-2-面试基本情况" class="headerlink" title="2.2 面试基本情况"></a>2.2 面试基本情况</h3><p>面试官比较随和，一开始简单了解一下一下毕业论文的相关情况，问了毕业论文的方向，所做的工作，由于我是我们组唯一一篇优秀论文，所以在这里回答的我自认为还是十分满意的，随后开始正式面试。</p><ul><li>简历中提到了做过网络监听方面的程序，简单解释一下ARP协议？</li><li>说一下HTTP和HTTPs的区别？</li><li>在做登录态验证的时候，cookie的作用？还有什么技术可以达到同样的效果？</li><li>CSS做对齐的时候，你能想到多少种不同的方式？</li><li>简历上有使用过Node.js，如何处理跨域问题？</li></ul><h3 id="2-3-算法相关"><a href="#2-3-算法相关" class="headerlink" title="2.3 算法相关"></a>2.3 算法相关</h3><p>第一题是一个非常简单的问题，将数组中的对象按照其键，分类组成一个新的对象。</p><pre><code class="javascript">//将列表中的对象按键值对的形式转换为对象let list1 = [{class: &quot;1&quot;,number: 1},              {class: &quot;1&quot;,number: 2},              { class: &quot;2&quot;,number: 1}]function mergerObject(array) {    output = {}    //遍历数组，为每个对象的class创建属性，并将其值初始化为数组    for (i of array) {        output[i.class] = new Array()    }    //遍历数组，将每个对象对应的number存储到对应的class中    for (i of array) {        output[i.class].push(i.number)    }    return output}console.log(mergerObject(list1))</code></pre><p>这一题我在写的时候，思路完全正确，但是for循环中给对象设置属性时忘记了加<code>.class</code>，导致题目输出错误，面试官因而认为我对JavaScript语言并不熟悉，这是非常遗憾的一个地方。</p><p>第二题是一个合并两个有序数组的问题，应该来说还是十分简单，最简单的做法是直接合并，再进行排序，但是我不想用这么简单的方法，一直在思考另一种方法，我也说出了正确的思路：设置两个指针，分别指向list1和list2的头部，然后比较两个元素，将较小的push进answerList数组，然后将其指针后移一位，直到遍历完毕。</p><p>但是使用牛客网的oj时仍然出现了错误，之后就特别紧张， 一直没有调试出结果，但事实上面试一结束，我自己做的时候很快就做出来了，也十分可惜。</p><pre><code class="javascript">//合并两个有序数组let a = [1, 2, 3, 4, 5, 7, 8, 9, 10]let b = [4, 5, 6, 7]function mergerTwoOrderedList(list1, list2) {    let answer = []    //使用两个指针，分别指向list1和list2的开头    let i = 0    let j = 0    //循环次数为两个数组的长度    for (let count = 0; count &lt; list1.length + list2.length; count++) {        //将小的元素push进answerList，指针往后指向一位，当指针出于数组末尾时，表示这个数组已经遍历完毕        if (list1[i] &lt; list2[j]) {            answer.push(list1[i])            if (i + 1 &lt; list1.length) {                i += 1            }            else {                list1[i] = list2[list2.length - 1]            }        }        else {            answer.push(list2[j])            if (j + 1 &lt; list2.length) {                j += 1            }            else {                list2[j] = list1[list1.length - 1]            }        }    }    return answer}//时间复杂度为O(m+n)，空间复杂度为O(m+n)console.log(mergerTwoOrderedList(b, a))</code></pre><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>目前来看，两个面试都凉凉了~~</p><ul><li>前端基础薄弱，并非框架，而是基本的基础，在平时使用工具开发经常被忽略的地方</li><li>平时算法题做的较少</li><li>当着面试官编程容易紧张，本来应该做出来的题没有做出来</li><li>百词斩本来抱有很大希望，因为前面感觉回答的真的不错，可惜算法题是在一言难尽</li></ul>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>web前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript继承</title>
    <link href="/2020/05/16/JavaScript%E7%BB%A7%E6%89%BF/"/>
    <url>/2020/05/16/JavaScript%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>关于JavaScript继承的一些实现方法。</p><a id="more"></a><h2 id="JavaScript继承"><a href="#JavaScript继承" class="headerlink" title="JavaScript继承"></a>JavaScript继承</h2><h3 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1 前置知识"></a>1 前置知识</h3><h4 id="1-1-JavaScript原型链"><a href="#1-1-JavaScript原型链" class="headerlink" title="1.1 JavaScript原型链"></a>1.1 JavaScript原型链</h4><p>关于原型链的内容，可以查看我的另一篇博客<a href="https://liutianjie.github.io/2020/05/15/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE/" target="_blank" rel="noopener">JavaScript原型链</a>，但是核心原理可以总结为：</p><ul><li>每一个实例对象（除了null）都存在<code>__proto__</code>属性</li><li>每一个函数都有一个prototype属性，指向其构造的对象的原型</li><li>每一个原型都有一个constructor，指向其关联的构造函数</li><li><code>实例对象</code>的<code>__proto__</code>属性指向<code>其原型对象</code>，实例对象的<code>构造函数</code>的<code>prototype</code>也指向<code>该</code>实例对象的<code>原型对象</code></li><li>原型对象也有原型，原型链的<code>起点</code>为具体的<code>实例对象</code>，终点为<code>Object</code>，Object的原型为null，即没有原型对象</li><li>一个对象的<code>原型对象</code>的<code>constructor</code>属性指向<code>该</code>对象的<code>构造函数</code></li><li>利用原型链可以进行多重继承</li></ul><h4 id="1-2-Object-create"><a href="#1-2-Object-create" class="headerlink" title="1.2 Object.create()"></a>1.2 Object.create()</h4><p>Object.create()函数的用法如下：</p><pre><code class="javascript">let a = {  name:&#39;liutao&#39;;};let obj = Object.create(a,  name: {        configurable: true,        enumerable: true,        value: &#39;kitty&#39;,        writable: true,    })</code></pre><p>Object.create()的第一个参数是用于obj继承的原型，后面是对a中参数的配置如可读写性、属性值等的定义。利用这个函数，我们可以方便的创建对象的继承关系，但是他的缺点是继承只能在创建对象时进行，非常不灵活。</p><h3 id="2-Object-create-prototype实现原型链继承"><a href="#2-Object-create-prototype实现原型链继承" class="headerlink" title="2 Object.create() + prototype实现原型链继承"></a>2 Object.create() + prototype实现原型链继承</h3><h4 id="2-1-利用原型链实现多重继承"><a href="#2-1-利用原型链实现多重继承" class="headerlink" title="2.1 利用原型链实现多重继承"></a>2.1 利用原型链实现多重继承</h4><pre><code class="javascript">function Father() {    this.name = &quot;name from Father&quot;}function Child() {    this.age = 12}Father.prototype.name = &quot;name form Father&#39;s prototype&quot;//startChild.prototype = Object.create(Father.prototype)Child.prototype.constructor = Child//endconst my = new Child()console.log(my.name) //&quot;name form Father&#39;s prototype&quot;</code></pre><p>start-end之间的代码，相当于将Child的原型指向Father的原型，同时将Child的原型的构造器指定为Child本身，通过他们之间的关系，构建出一条链条。</p><p>这样，执行<code>console.log(my.name)</code>时，先从本身查找name属性，再从my的原型即Child的<code>prototype</code>查找，再从Father的<code>prototype</code>查找，最后从Object的<code>prototype</code>查找，通过这条原型链实现了多重继承。</p><blockquote><p>start-end之间的代码也可以写成：</p><pre><code class="javascript">Child.prototype = new Father()Child.prototype.constructor = Child</code></pre></blockquote><h4 id="2-2-原型链继承的弊端"><a href="#2-2-原型链继承的弊端" class="headerlink" title="2.2 原型链继承的弊端"></a>2.2 原型链继承的弊端</h4><p>使用原型链继承有一些弊端，因为继承的属性来自于共享的原型的属性，所以实例化多个对象时，如果对其中一个实例的继承属性进行修改，则会影响所有的实例：</p><pre><code class="javascript">function Father() {    this.list = [1, 2, 3, 4, 5]}function Child() {}Father.prototype.list = [1, 2, 3, 4, 5]Child.prototype = new Father()let c1 = new Child()let c2 = new Child()console.log(c1.list)console.log(c2.list)c1.list.push(6)console.log(&quot;================&quot;)console.log(c1.list)console.log(c2.list)/*[ 1, 2, 3, 4, 5 ][ 1, 2, 3, 4, 5 ]================[ 1, 2, 3, 4, 5, 6 ][ 1, 2, 3, 4, 5, 6 ]*/</code></pre><p>上面的代码修改了c1.list，但是c2.list也发生了变换</p><h3 id="3-利用构造函数继承"><a href="#3-利用构造函数继承" class="headerlink" title="3 利用构造函数继承"></a>3 利用构造函数继承</h3><h4 id="3-1-构造函数继承"><a href="#3-1-构造函数继承" class="headerlink" title="3.1 构造函数继承"></a>3.1 构造函数继承</h4><pre><code class="javascript">function Father() {  this.list = [1, 2, 3, 4, 5]}function Child() {  Father.call(this);}let c1 = new Child();let c2 = new Child();console.log(c1.list); console.log(c2.list); c1.list.push(6)console.log(&quot;================&quot;)console.log(c1.list); console.log(c2.list); /*[ 1, 2, 3, 4, 5 ][ 1, 2, 3, 4, 5 ]================[ 1, 2, 3, 4, 5, 6 ][ 1, 2, 3, 4, 5 ]*/</code></pre><p>可以看出，在new一个Child实例时，实际上是执行了Father中的初始化代码，这样每个实例都拥有自己的副本。</p><h4 id="3-2-构造函数继承的弊端"><a href="#3-2-构造函数继承的弊端" class="headerlink" title="3.2 构造函数继承的弊端"></a>3.2 构造函数继承的弊端</h4><p>仅利用构造函数，方法都在构造函数中进行定义，将会降低函数的复用性，而且对于子类的构造函数来讲，定义在父类型原型上的方法对于子类的构造函数是不可见的。导致所有的类型都只能使用构造函数模式。因此借用构造函数的这个办法也很少单独使用。</p><h3 id="4-组合继承"><a href="#4-组合继承" class="headerlink" title="4 组合继承"></a>4 组合继承</h3><h4 id="3-2-利用原型链和apply-实现组合继承"><a href="#3-2-利用原型链和apply-实现组合继承" class="headerlink" title="3.2 利用原型链和apply()实现组合继承"></a>3.2 利用原型链和apply()实现组合继承</h4><p>结合2和3，很容易可以得出组合继承的方法，这也是JavaScript的经典继承方法。</p><pre><code class="javascript">function Father() {    this.name = &quot;name from Father&quot;    this.list = [1, 2, 3, 4, 5]}function Child() {    this.age = 12;    Father.call(this)}Father.prototype.getList = function () {    return this.list}//startChild.prototype = Object.create(Father.prototype)//Child.prototype = new Father()Child.prototype.constructor = Child//endconst c1 = new Child()const c2 = new Child()console.log(c1.list)console.log(c2.list)c1.list.push(6)console.log(&quot;================&quot;)console.log(c1.list);console.log(c2.list);console.log(&quot;================&quot;)console.log(c1.getList())console.log(c2.getList())  </code></pre><p>其中属性继承自Father类，方法则继承自原型链。</p><hr><h3 id="5-24更新"><a href="#5-24更新" class="headerlink" title="==5.24更新=="></a>==5.24更新==</h3><h4 id="ES6中的继承方法"><a href="#ES6中的继承方法" class="headerlink" title="ES6中的继承方法"></a>ES6中的继承方法</h4><p>使用<code>class</code>关键字定义类，使用<code>extends</code>关键字继承</p><pre><code class="javascript">class Person{    cosntructor(name){        this.name = name        this.life = 100        this.status = &quot;alive&quot;    }    attack(obj){        if(this.life&gt;0){            if(obj.life&gt;0 &amp;&amp; obj.status==&quot;alive&quot;)            obj.life -=this.weapon.attackNum            else            obj.status = &#39;dead&#39;        }        else{            throw new Error(&quot;You&#39;re already dead!&quot;)        }    }}class Police extends Person{    constructor(name,weapon){        super(name)        this.weapon = weapon    }}let po1 = new Police(&quot;xiaoming&quot;,{name:&quot;handgun&quot;,attackNum = 10})let po2 = new Police(&quot;xiaoming&quot;,{name:&quot;AWM&quot;,attackNum = 100})po2.attack(po1)console.log(po1.status)//dead</code></pre><ul><li>在子类的构造方法中，必须先调用<code>super</code>方法，拿到父类的<code>this</code>对象。如果没有显式的调用，也会默认调用。</li><li>在调用子类的方法时，使用的均为子类的<code>this</code>，即使使用<code>super</code>关键字来调用也是如此。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript原型链</title>
    <link href="/2020/05/15/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2020/05/15/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>简单梳理一下JavaScript原型链。</p><a id="more"></a><h2 id="JavaScript原型链"><a href="#JavaScript原型链" class="headerlink" title="JavaScript原型链"></a>JavaScript原型链</h2><p>首先用一张图来描述原型链。</p><img src="http://images.nickname4th.vip/proto.png" srcset="/img/loading.gif" alt="proto" style="zoom:50%;" /><h3 id="1-JavaScript创建对象的方式"><a href="#1-JavaScript创建对象的方式" class="headerlink" title="1 JavaScript创建对象的方式"></a>1 JavaScript创建对象的方式</h3><ul><li><p>字面量</p><pre><code class="javascript">let obj1 = {name:&#39;liutao&#39;};let obj2 = new Object({name:&#39;liutao&#39;});</code></pre></li><li><p>构造函数</p><pre><code class="javascript">let M = function(name){  this.name = name;}let obj3 = new M(&#39;liutao&#39;)</code></pre></li><li><p>create方法</p><pre><code class="javascript">let obj = {name:&#39;liutao&#39;}let obj4 = Object.create(obj)</code></pre></li></ul><h3 id="2-相关的关键字"><a href="#2-相关的关键字" class="headerlink" title="2 相关的关键字"></a>2 相关的关键字</h3><ul><li>实例对象</li><li>原型对象</li><li>构造函数</li><li>Function构造函数</li><li>Object构造函数</li><li>Function原型</li><li>Object原型</li></ul><h3 id="3-联系"><a href="#3-联系" class="headerlink" title="3 联系"></a>3 联系</h3><h4 id="3-1-设定（约定俗成）"><a href="#3-1-设定（约定俗成）" class="headerlink" title="3.1 设定（约定俗成）"></a>3.1 设定（约定俗成）</h4><ul><li>每一个实例对象（除了null）都存在__proto__属性</li><li>每一个函数都有一个prototype属性，指向其构造的对象的原型</li><li>每一个原型都有一个constructor，指向其关联的构造函数</li></ul><h4 id="3-2-基本原则"><a href="#3-2-基本原则" class="headerlink" title="3.2 基本原则"></a>3.2 基本原则</h4><ul><li><p><code>实例对象</code>的<code>__proto__</code>属性指向<code>其原型对象</code>，实例对象的<code>构造函数</code>的<code>prototype</code>也指向<code>该</code>实例对象的<code>原型对象</code></p></li><li><p>原型对象也有原型，原型链的<code>起点</code>为具体的<code>实例对象</code>，终点为<code>Object</code>，Object的原型为null，即没有原型对象</p></li><li><p>一个对象的<code>原型对象</code>的<code>constructor</code>属性指向<code>该</code>对象的<code>构造函数</code></p></li><li><p>利用原型链可以进行多重继承</p></li></ul><h4 id="3-2-实例的-proto-属性和prototype属性"><a href="#3-2-实例的-proto-属性和prototype属性" class="headerlink" title="3.2 实例的__proto__属性和prototype属性"></a>3.2 实例的__proto__属性和prototype属性</h4><pre><code class="javascript">let obj1 = {name:&#39;liutao&#39;};    //字面量创建一个实例对象let M = function(name){     //M是构造函数  this.name = name;}let obj2 = new M(&#39;liutao&#39;);    //构造函数创建一个实例对象console.log(obj1.__proto__);//{}，即obj1的原型对象console.log(obj2.__proto__);//M{}，即obj2的原型对象console.log(obj2.__proto__===M.prototype)//通过3.1可知M.prototype指向其构造的对象即obj2的原型//这里可以得出，字面量实例对象的__proto__属性和构造函数实例对象的__proto__属性指向各自的原型对象</code></pre><h4 id="3-3-原型对象的-proto-属性和prototype属性"><a href="#3-3-原型对象的-proto-属性和prototype属性" class="headerlink" title="3.3 原型对象的__proto__属性和prototype属性"></a>3.3 原型对象的__proto__属性和prototype属性</h4><pre><code class="javascript">console.log(obj1.__proto__.__proto__);//null，由于obj1是由Object构造函数创建的，所以obj1.__proto__指向Object的prototype，而obj1.__proto__.__proto__指向Object的原型，即nullconsole.log(obj2.__proto__.__proto__);//{}，由于obj2是由M构造函数创建的，所以obj2.__proto__指向M.prototype，而M是由Object构造函数创建的，所以obj2.__proto__.__proto__指向M.prototype.__proto__，即Object.__proto__，即obj1.__proto__//验证console.log(obj2.__proto__.__proto__ === obj1.__proto__);//trueconsole.log(obj2.__proto__.__proto__.__proto__);//false</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>原型链的图其实画的不太好，但是只要理解了3.1和3.2的内容，就很容易理解原型链了。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Vue和MQTT的简单IOT系统</title>
    <link href="/2020/05/13/%E5%9F%BA%E4%BA%8EVue%E5%92%8CMQTT%E7%9A%84%E7%AE%80%E5%8D%95IOT%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/05/13/%E5%9F%BA%E4%BA%8EVue%E5%92%8CMQTT%E7%9A%84%E7%AE%80%E5%8D%95IOT%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>最近有个同学有点需求，简单帮忙实现了一下，前端部分使用了Vue+ElementUI，后端部分使用了MongoDB，中间使用MQTT协议的“发布——订阅”模式实现消息的传递。之前使用Docker在腾讯云搭建了一个环境，传送门<a href="https://github.com/LiuTianjie/zc_web" target="_blank" rel="noopener">A lot project build with Vue and Docker</a>，如果你没有docker的相关知识，可以直接查看代码的web和server文件夹即可。</p><a id="more"></a><h2 id="基于Vue和MQTT的简单IOT系统"><a href="#基于Vue和MQTT的简单IOT系统" class="headerlink" title="基于Vue和MQTT的简单IOT系统"></a>基于Vue和MQTT的简单IOT系统</h2><img src="http://images.nickname4th.vip/zc_bb.png" srcset="/img/loading.gif" alt="zc_bb" style="zoom: 25%;" /><p>整个系统可以分为前端、后端和硬件三个部分，前端通过模拟购票和开锁与后端数据库交互，并通过MQTT协议与树莓派通信，树莓派控制GPIO引脚信号控制IOT设备。</p><h3 id="1-前端部分"><a href="#1-前端部分" class="headerlink" title="1 前端部分"></a>1 前端部分</h3><h4 id="1-1-全局http处理"><a href="#1-1-全局http处理" class="headerlink" title="1.1 全局http处理"></a>1.1 全局http处理</h4><pre><code class="javascript">import axios from &#39;axios&#39;import Vue from &#39;vue&#39;const http = axios.create({    baseURL: &#39;url&#39;})http.interceptors.response.use(res =&gt; {    return res}, err =&gt; {    //服务端返回错误通用处理方案，并使用element的message进行提示    if (err.response.data) {        Vue.prototype.$message.error({            type: &#39;error&#39;,            message: err.response.data        });        console.log(err.response.status)    }    return Promise.reject(err)})export default http</code></pre><p>使用axios进行网络请求，添加http拦截器，将服务端返回的错误码和信息返回。</p><h4 id="1-2-模拟购票"><a href="#1-2-模拟购票" class="headerlink" title="1.2 模拟购票"></a>1.2 模拟购票</h4><p>简单的表单验证，利用vue的ref引用一个p标签来展示购票结果。</p><pre><code class="vue">&lt;div class=&quot;buy&quot; v-loading.fullscreen.lock=&quot;loading&quot;&gt;  &lt;el-card header=&quot;购买车票（模拟）&quot; class=&quot;check-card&quot;&gt;    &lt;div class=&quot;info&quot;&gt;      &lt;p ref=&quot;answer&quot;&gt;&lt;/p&gt;    &lt;/div&gt;  &lt;/el-card&gt;&lt;/div&gt;&lt;script&gt;methods: {    check() {      let that = this;      this.$refs[&quot;formData&quot;].validate(async valid =&gt; {        if (valid) {          this.$refs.answer.innerHTML = &quot;购票中，请稍后&quot;;          this.loading = true;          try {            const res = await this.$http.post(&quot;/orders&quot;, this.formData);            setTimeout(() =&gt; {              this.loading = false;              this.$message({                message: &quot;购票成功！&quot;,                type: &quot;success&quot;              });            }, 500);            this.resetForm(&quot;formData&quot;);            this.$refs.answer.innerHTML = `购票成功！&lt;/p&gt;&lt;p&gt;          日期：${res.data.date}&lt;/p&gt;&lt;p&gt;          车次：${res.data.train}&lt;/p&gt;&lt;p&gt;          座位：${res.data.set}`;          } catch (err) {            setTimeout(() =&gt; {              this.loading = false;              this.$refs.answer.innerHTML = &quot;购票失败！&quot;;            }, 500);          }        } else {          this.$message.error(&quot;输入有误，请重试！&quot;);        }      });    },}&lt;/script&gt;</code></pre><ul><li>使用了v-loading做等待时的缓冲动画</li><li>利用ref控制购票状态</li></ul><h4 id="1-2-模拟验证"><a href="#1-2-模拟验证" class="headerlink" title="1.2 模拟验证"></a>1.2 模拟验证</h4><pre><code class="vue">&lt;el-form :model=&quot;formData&quot; ref=&quot;formData&quot; label-width=&quot;100px&quot; @submit.native.prevent=&quot;check&quot;&gt;  &lt;el-form-item    label=&quot;身份证号&quot;    prop=&quot;id&quot;    :rules=&quot;[              { required: true, message: &#39;身份证号码不能为空&#39;},              { required: true, message: &#39;请填写证件号码&#39;, trigger: &#39;blur&#39; },              { pattern: /(^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$)|(^[1-9]\d{5}\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{2}$)/,                message: &#39;证件号码格式有误！&#39;,                trigger: &#39;blur&#39;              }]&quot;&gt;    &lt;el-input      class=&quot;check-box&quot;      type=&quot;id&quot;      v-model=&quot;formData.id&quot;      autocomplete=&quot;off&quot;      placeholder=&quot;请输入身份证号码&quot;&gt;    &lt;/el-input&gt;  &lt;/el-form-item&gt;     &lt;el-button type=&quot;primary&quot; native-type=&quot;submit&quot;&gt;提交&lt;/el-button&gt;     &lt;el-button @click=&quot;resetForm(&#39;formData&#39;)&quot;&gt;重置&lt;/el-button&gt;   &lt;/el-form-item&gt;&lt;/el-form&gt;</code></pre><ul><li>使用element表单验证，rules中使用正则表达式限制身份证号码的格式</li><li>@submit.native.prevent=”check”，阻止表单的自动提交</li><li>提交按钮绑定native-type=”submit”，点击提交</li></ul><h3 id="2-后端部分"><a href="#2-后端部分" class="headerlink" title="2 后端部分"></a>2 后端部分</h3><h4 id="2-1-MQTT-Server"><a href="#2-1-MQTT-Server" class="headerlink" title="2.1 MQTT Server"></a>2.1 MQTT Server</h4><pre><code class="javascript">var mosca = require(&#39;mosca&#39;);//构建自带服务器var MqttServer = new mosca.Server({    port: 1883});//对服务器端口进行配置， 在此端口进行监听MqttServer.on(&#39;clientConnected&#39;, function (client) {    //监听连接    console.log(&#39;client connected&#39;, client.id);});/** * 监听MQTT主题消息 **/MqttServer.on(&#39;published&#39;, function (packet, client) {    //当客户端有连接发布主题消息    var topic = packet.topic;    console.log(packet);    switch (topic) {        case &#39;train1&#39;:            console.log(&#39;message-publish&#39;, packet.payload.toString());            //MQTT转发主题消息            //MqttServer.publish({ topic: &#39;other&#39;, payload: &#39;sssss&#39; });            break;        case &#39;train2&#39;:            console.log(&#39;message-123&#39;, packet.payload.toString());            break;    }});MqttServer.on(&#39;ready&#39;, function () {    //当服务开启时    console.log(&#39;mqtt is running...&#39;);});</code></pre><ul><li>通过mosca新建mqtt服务器，监听1883端口</li><li>利用switch函数，监听从客户的publish的消息</li></ul><h4 id="2-2-Express服务器接口"><a href="#2-2-Express服务器接口" class="headerlink" title="2.2 Express服务器接口"></a>2.2 Express服务器接口</h4><pre><code class="javascript">const Model = require(&#39;../../models/Order&#39;)const mqtt = require(&#39;mqtt&#39;);const client = mqtt.connect(&#39;mqtt://host&#39;); //连接到服务端//验证并删除订单记录router.get(&#39;/orders/:id&#39;, async (req, res) =&gt; {  const item = await Model.findOne({ user: req.params.id })  if (item === null) {    res.status(401).send(&quot;未查到数据！&quot;)  }  else {    const id = item._id    console.log(item)    const msg = await Model.findOneAndDelete({ _id: id })    console.log(&quot;使用成功！已删除！&quot;)    res.send(item)    client.publish(&#39;train1&#39;, msg.set+&#39;&#39;, { qos: 0, retain: true });  }})</code></pre><ul><li>使用express的router定义后端路由，通过url传递参数匹配特定用户的id，进行CURD操作</li><li>创建mqtt客户端，删除时向“train1”频道发布信息</li></ul><h3 id="3-硬件部分"><a href="#3-硬件部分" class="headerlink" title="3 硬件部分"></a>3 硬件部分</h3><h4 id="3-1-示意图和电路图"><a href="#3-1-示意图和电路图" class="headerlink" title="3.1 示意图和电路图"></a>3.1 示意图和电路图</h4><ul><li>示意图</li></ul><img src="http://images.nickname4th.vip/zc_bb.png" srcset="/img/loading.gif" alt="zc_bb" style="zoom: 25%;" /><ul><li>电路图</li></ul><img src="http://images.nickname4th.vip/zc_图示.png" srcset="/img/loading.gif" alt="zc_图示" style="zoom:25%;" /><ul><li><p>GPIO 11 连接至L298N驱动板的ENA，用于发送高低电平信号，GPIO 35、36连接L298N的IN1、IN2，用于控制OUT1的输出，L298N真值表如下：</p><table><thead><tr><th align="center">ENA</th><th align="center">IN1</th><th align="center">IN2</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">x</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">+12V</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">-12V</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table></li></ul><h4 id="3-2-MQTT-Client"><a href="#3-2-MQTT-Client" class="headerlink" title="3.2 MQTT Client"></a>3.2 MQTT Client</h4><pre><code class="javascript">var mqtt = require(&#39;mqtt&#39;);//指定服务端地址和端口var client2 = mqtt.connect(&quot;host:1883&quot;);//引入Node.js操作GPIO的库var rpio = require(&#39;rpio&#39;);const player = require(&#39;play-sound&#39;)();rpio.open(12, rpio.OUTPUT);rpio.open(35, rpio.OUTPUT, rpio.HIGH);rpio.open(36, rpio.OUTPUT, rpio.LOW);//MQTT客户端订阅主题train1client2.subscribe(&#39;train1&#39;, { qos: 1 });//订阅主题为train1的消息  //当客户端收到消息时，在控制台输出消息内容，client2.on(&#39;message&#39;, function (top, message) {  //收到验证信息后，验证  rpio.write(11, rpio.HIGH);  rpio.msleep(800)  rpio.write(11, rpio.LOW);  console.log(message.toString() + &#39;号锁已开启！&#39;);  player.play(&#39;./open.mp3&#39;, (err) =&gt; {    if (err) console.log(`Could not play sound: ${err}`);  });  setTimeout(player.play(&#39;./close.mp3&#39;, (err) =&gt; {    if (err) console.log(`Could not play sound: ${err}`);  }), 100000)});</code></pre><ul><li>在<a href="https://www.jianshu.com/p/5cf4df8806c0" target="_blank" rel="noopener">树莓派配置好Node环境</a>，安装MQTT协议的库，订阅相应的主题，在客户端发起对物联网设备的操作请求时，在通过校验后，即可进行相应的操作</li><li>可以根据订阅消息的具体内容再进一步判断操作，但是注意消息内容仅能以字符串形式传递。</li></ul>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>MQTT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Vue和Express的登录注册系统</title>
    <link href="/2020/05/07/%E5%9F%BA%E4%BA%8EVue%E5%92%8CExpress%E7%9A%84%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/05/07/%E5%9F%BA%E4%BA%8EVue%E5%92%8CExpress%E7%9A%84%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>这是一个简单的登录注册示例，包含了登录、注册和用户页面三个部分。本示例的代码保存在我的github仓库，如有不清楚的地方可以下载查阅。<a href="https://github.com/LiuTianjie/LoginSystem" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><h2 id="基于Vue和express的登录注册系统"><a href="#基于Vue和express的登录注册系统" class="headerlink" title="基于Vue和express的登录注册系统"></a>基于Vue和express的登录注册系统</h2><h3 id="1-前端部分"><a href="#1-前端部分" class="headerlink" title="1 前端部分"></a>1 前端部分</h3><h4 id="1-1-UI"><a href="#1-1-UI" class="headerlink" title="1.1 UI"></a>1.1 UI</h4><p>UI方面使用了Element UI的按钮、表单和消息通知等组件。</p><ul><li><p>引入ElementUI</p><pre><code class="shell">vue add element-ui</code></pre></li><li><p>使用ElementUI</p><pre><code class="javascript">//element.jsimport Vue from &#39;vue&#39;import Element from &#39;element-ui&#39;import &#39;element-ui/lib/theme-chalk/index.css&#39;Vue.use(Element)/*这里是全局导入，将ElementUI可用的组件全部挂载到Vue上,这样我们就可以直接使用其组件了，如Vue.prototype.$message等</code></pre></li></ul><h4 id="1-2-网络请求http-js"><a href="#1-2-网络请求http-js" class="headerlink" title="1.2 网络请求http.js"></a>1.2 网络请求http.js</h4><p>前端网络请求使用了axios，通过async—await语法实现异步请求。</p><ul><li><p>引入axios</p><pre><code class="shell">npm install vue-axios</code></pre></li><li><p>配置http.js</p><pre><code class="javascript">import axios from &#39;axios&#39;import Vue from &#39;vue&#39;import router from &#39;./router/index&#39;const http = axios.create({    baseURL: &#39;http://localhost:3030&#39;})//拦截器http.interceptors.request.use((config) =&gt; {    if (localStorage.token) {        config.headers.Authorization = &#39;Bearer &#39; + localStorage.token    }    return config})http.interceptors.response.use(res =&gt; {    return res}, err =&gt; {  //服务器无响应    if (!err.response) {        Vue.prototype.$message.error({            type: &#39;error&#39;,            message: &quot;服务器连接失败&quot;        });        return Promise.reject(err)    }    //服务端返回错误通用处理方案    if (err.response.data.message) {        Vue.prototype.$message.error({            type: &#39;error&#39;,            message: err.response.data.message        });        // console.log(err.response.status)        if (err.response.status === 401) {            router.push(&#39;/login&#39;)        }    }    // console.log(err.response.data.message)    return Promise.reject(err)})export default http</code></pre><p>上述代码进行了如下操作：</p><ul><li><p>配置了请求接口的Baseurl，请求时通过拼接访问具体接口，有利于隐私性。</p></li><li><p>添加了请求拦截器，配合后端的权限机制，在访问需要用户登录后才能使用的页面时，在请求头中添加token，供后端验证。</p></li><li><p>添加了全局错误处理的拦截，配合服务端返回的错误代码和信息，进行相应的展示和跳转，如这里收到服务端401代码则返回登录页面。</p></li><li><p>抛出http模块，在main.js中将其挂载到Vue的原型对象，便于直接通过<strong>this</strong>来使用。</p><pre><code class="javascript">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#39;./plugins/element.js&#39;import router from &#39;./router&#39;import http from &#39;./http&#39;Vue.prototype.$http = httpVue.config.productionTip = falsenew Vue({  router,  render: h =&gt; h(App)}).$mount(&#39;#app&#39;)</code></pre></li></ul></li></ul><h4 id="1-3-前端路由"><a href="#1-3-前端路由" class="headerlink" title="1.3 前端路由"></a>1.3 前端路由</h4><p>使用vue-router实现前端路由。</p><ul><li><p>引入vue-router</p><pre><code class="shell">vue add vue-router --save</code></pre></li><li><p>定义router.js</p><p>本示例中包含3个页面，相应的配置为：</p><pre><code class="javascript">import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;Vue.use(VueRouter)const routes = [  {    path: &#39;/&#39;,    name: &#39;Login&#39;,    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#39;../views/Login.vue&#39;),    meta: { isPublic: true }  },  {    path: &#39;/login&#39;,    name: &#39;Login&#39;,    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#39;../views/Login.vue&#39;),    meta: { isPublic: true }  },  {    path: &#39;/signup&#39;,    name: &#39;SignUp&#39;,    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#39;../views/SignUp.vue&#39;),    meta: { isPublic: true }  },  {    path: &#39;/index:id&#39;,    name: &#39;index&#39;,    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#39;../views/index.vue&#39;),    meta: { isPublic: false }  },  {    path: &#39;*&#39;,    name: &#39;notfound&#39;,    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#39;../views/notfound.vue&#39;)  }]</code></pre><ul><li><p>通过meta属性限定页面是否公开，配合全局导航守卫进行路由判断。</p></li><li><p>通过’*’路由加入404页面。</p></li></ul></li></ul><h5 id="1-3-1-全局导航守卫"><a href="#1-3-1-全局导航守卫" class="headerlink" title="1.3.1 全局导航守卫"></a>1.3.1 全局导航守卫</h5><pre><code class="javascript">router.beforeEach((to, from, next) =&gt; {  if (!to.meta.isPublic &amp;&amp; !localStorage.token) {    Vue.prototype.$message({      type: &quot;warning&quot;,      message: &quot;请先登录&quot;    });    next(&#39;/login&#39;)  }  next()})</code></pre><p>在页面跳转之前进行相应的判断，主要在非法访问页面时跳转到login页面。</p><h4 id="1-4-登录"><a href="#1-4-登录" class="headerlink" title="1.4 登录"></a>1.4 登录</h4><h5 id="1-4-1-Login-vue"><a href="#1-4-1-Login-vue" class="headerlink" title="1.4.1 Login.vue"></a>1.4.1 Login.vue</h5><pre><code class="vue">&lt;script&gt;export default {  name: &quot;app&quot;,  data() {    return {      form: {        account: &quot;&quot;,        psw: &quot;&quot;      }    };  },  components: {},  methods: {    async toLogin() {      if (this.form.psw === &quot;&quot; || this.form.account===&quot;&quot;) {        this.$notify({          title: &quot;输入错误&quot;,          message: &quot;请检查账户和密码！&quot;,          type: &quot;error&quot;        });      } else {        const res = await this.$http.post(&quot;login&quot;, this.form);        localStorage.token = res.data.token;        this.$message({          type: &quot;success&quot;,          message: &quot;登录成功&quot;        });        this.$router.push({ path: `./index${this.form.account}` });      }    },    toSignUp() {      this.$router.push({ path: &quot;./signup&quot; });    }  }};&lt;/script&gt;</code></pre><p>通过定义的toLogin方法进行登录，在前端限制了账户和密码非空，并通过Element的message进行提示。通过POST方法将表单数据。</p><h4 id="1-5-注册"><a href="#1-5-注册" class="headerlink" title="1.5 注册"></a>1.5 注册</h4><h5 id="1-5-1-SignUp-vue"><a href="#1-5-1-SignUp-vue" class="headerlink" title="1.5.1 SignUp.vue"></a>1.5.1 SignUp.vue</h5><pre><code class="vue">&lt;script&gt;export default {  methods: {    toLogin() {      this.$router.push({ path: &quot;./login&quot; });    },    async toSignUp() {      try {        this.loading = true;        const res = await this.$http.post(&quot;/api/users&quot;, this.form);        this.$message({          type: &quot;success&quot;,          message: &quot;注册成功&quot;        });        this.loading = false;      } catch (error) {        this.$message({          type: &quot;error&quot;,          message: &quot;注册失败&quot;        });        this.loading = false;      }      this.clear();    },&lt;/script&gt;</code></pre><h5 id="1-5-2-表单验证"><a href="#1-5-2-表单验证" class="headerlink" title="1.5.2 表单验证"></a>1.5.2 表单验证</h5><pre><code class="javascript">data() {  //验证用户名  var checkAccount = async (rule, value, callback) =&gt; {    if (value === &quot;&quot;) {      this.accountValid = false;      callback(new Error(&quot;账户不能为空&quot;));    } else {      const res = await this.$http.get(`/${this.form.account}`);      if (res.data) {        this.accountValid = false;        callback(new Error(&quot;用户已存在&quot;));      } else {        this.accountValid = true;        callback();      }    }  };  //验证密码1  var checkpsw1 = (rule, value, callback) =&gt; {    if (value === &quot;&quot;) {      this.psw1Valid = false;      callback(new Error(&quot;密码不能为空&quot;));    } else {      if (this.form.psw1 !== &quot;&quot;) {        this.$refs.form.validateField(&quot;psw2&quot;);      }      this.psw1Valid = true;      callback();    }  };  var checkpsw2 = (rule, value, callback) =&gt; {    if (value === &quot;&quot;) {      this.psw2Valid = false;      callback(new Error(&quot;请再次输入密码&quot;));    } else if (value !== this.form.psw1) {      this.psw2Valid = false;      callback(new Error(&quot;两次输入密码不一致!&quot;));    } else {      this.psw2Valid = true;      callback();    }  };  return {    form: {      account: &quot;&quot;,      psw1: &quot;&quot;,      psw2: &quot;&quot;,      check: &quot;&quot;    },    loading: false,    hasRead: false,    accountValid: false,    psw1Valid: false,    psw2Valid: false,    rules: {      account: [{ required: true, validator: checkAccount, trigger: &quot;blur&quot; }],      psw1: [{ required: true, validator: checkpsw1, trigger: &quot;blur&quot; }],      psw2: [{ required: true, validator: checkpsw2, trigger: &quot;blur&quot; }]    }  };},};</code></pre><p>表单验证使用了Element 的表单组件，通过callback函数和rule规则实现。其中触发规则为”blur”。</p><ul><li><p>使用V-model绑定表单的值，通过hasRead等布尔值限制提交。</p></li><li><p>使用了loading组件对注册时的页面进行遮罩。</p></li><li><p>当且仅当5个条件判断的布尔值全部符合条件时，才允许提交注册请求。</p></li><li><p>一次注册成功之后，清除表单数据。</p></li></ul><h3 id="2-后端部分"><a href="#2-后端部分" class="headerlink" title="2 后端部分"></a>2 后端部分</h3><p>后盾的数据库采用MongoDB，通过Node.js的mongoose插件进行数据库的操作。</p><h4 id="2-1登录接口"><a href="#2-1登录接口" class="headerlink" title="2.1登录接口"></a>2.1登录接口</h4><pre><code class="javascript">    //登录接口    app.post(&#39;/login&#39;, async (req, res) =&gt; {        const { account, psw } = req.body        //根据用户名找用户        const user = await User.findOne({ account }).select(&#39;+psw&#39;)        assert(user, 422, &#39;用户不存在&#39;)        //校验密码        const isValid = require(&#39;bcrypt&#39;).compareSync(psw, user.psw)        assert(isValid, 422, &#39;用户名或密码错误&#39;)        //签名返回token        const token = jwt.sign({            _id: user._id,            id: user._id,            username: user.account        }, app.get(&#39;secret&#39;))        res.send({ token })    })</code></pre><p>登录时，通过解构赋值提取Post请求体中的账户和密码。登录验证的步骤如下：</p><ul><li>根据用户名在数据库中查找用户信息，使用assert判断是否查找成功，若查找失败，服务端返回422错误，附带用户不存在的信息。</li><li>成功查找到用户后，使用bcrypt模块生成密码的摘要，与数据库中的摘要进行对比，如果对比失败，则服务端返回422错误，附带账户或密码错误的信息。</li><li>密码验证通过后，使用JSONWebToken进行签名，密钥为定义在服务端的密钥，返回200状态码，并返回token</li></ul><h4 id="2-2-注册接口"><a href="#2-2-注册接口" class="headerlink" title="2.2 注册接口"></a>2.2 注册接口</h4><pre><code class="javascript">router.post(&#39;/&#39;, async (req, res) =&gt; {        assert(req.body.psw1 === req.body.psw2, 422, &#39;两次密码不一致&#39;)        const accountLocal = await User.findOne({ account: req.body.account })        assert(!accountLocal, 502, &quot;用户已存在&quot;)        const model = {}        model.account = req.body.account;        model.psw = req.body.psw1        await req.Model.create(model)        res.send(model)    })</code></pre><p>注册时，除了前端限制，也要在后端进行相应的处理，以避免绕过前端的恶意注册，注册步骤如下：</p><ul><li>检验请求体的两次密码是否一致，不一致则返回422错误，附带两次密码不一致信息</li><li>若两次密码一致，则根据请求体的用户名在数据库进行查找，如果用户已经存在，则返回502错误，附带用户已存在的信息。</li><li>若无误，根据请求体的用户名和密码创建用户，存放到数据库中，其中密码经过bcrypt进行hash，而不是直接存放铭文。</li></ul><h4 id="2-3-用户数据模型"><a href="#2-3-用户数据模型" class="headerlink" title="2.3 用户数据模型"></a>2.3 用户数据模型</h4><pre><code class="javascript">const mongoose = require(&#39;mongoose&#39;)const schema = new mongoose.Schema({    account: { type: String },    psw: {        type: String,        select: false,        set(val) {            return require(&#39;bcrypt&#39;).hashSync(val, 10)        },    }})module.exports = mongoose.model(&#39;User&#39;, schema)</code></pre><p>其中定义psw字段时使用set方法通过bcrypt对密码进行hash签名，生成摘要。用户在数据库中存储的方式为：</p><img src="http://images.nickname4th.vip/用户在数据库中的存储信息.png" srcset="/img/loading.gif" alt="用户在数据库中的存储信息" style="zoom:50%;" /><h4 id="2-4-全局错误处理"><a href="#2-4-全局错误处理" class="headerlink" title="2.4 全局错误处理"></a>2.4 全局错误处理</h4><pre><code class="javascript">app.use(async (err, req, res, next) =&gt; {  res.status(err.statusCode || 500).send({    message: err.message  })})</code></pre><p>配合前端的http拦截器，返回错误信息。</p><h3 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3 中间件"></a>3 中间件</h3><h4 id="3-1-auth-js"><a href="#3-1-auth-js" class="headerlink" title="3.1 auth.js"></a>3.1 auth.js</h4><p>登录成功之后，对应用户访问自己资源的行为需要通过token来鉴定是否具有相应的权限。</p><pre><code class="javascript">//auth.jsmodule.exports = options =&gt; {    const jwt = require(&#39;jsonwebtoken&#39;)    const oUser = require(&#39;../models/User&#39;)    const assert = require(&#39;http-assert&#39;)    return async (req, res, next) =&gt; {        const token = String(req.headers.authorization || &#39;&#39;).split(&#39; &#39;).pop()        assert(token, 401, &#39;登录已过期&#39;)        try {            const { id } = jwt.verify(token, req.app.get(&#39;secret&#39;))            // console.log(id)            assert(id, 401, &#39;账户存在问题！&#39;)            req.user = await oUser.findById(id)            assert(req.user._id, 401, &quot;登录已过期&quot;)        } catch (error) {            return res.status(401).send({ message: &#39;登录已过期&#39; })        }        // console.log(req.user)        await next()    }}</code></pre><p>在具体使用时，如下面的获取用户页面的请求：</p><pre><code class="javascript">const auth = require(&#39;../middle/auth&#39;)//查看个人信息router.get(&#39;/&#39;, auth(), async (req, res) =&gt; {  console.log(&quot;user&quot;, req.user.account)  // const model = await req.Model.findOne({ account: req.user.account })  res.send(req.user.account)})</code></pre><p>通过express的Router，在收到前端GET请求后，先通过CommJS的require语法执行上面auth.js中的代码，进行权限验证。</p><h4 id="3-2-resources-js"><a href="#3-2-resources-js" class="headerlink" title="3.2 resources.js"></a>3.2 resources.js</h4><p>在将来如果有更多的资源，我们可以将接口统一起来，根据前端的需求动态的请求后端的资源，这样更加灵活方便。</p><pre><code class="javascript">//resource.jsmodule.exports = options =&gt; {    return async (req, res, next) =&gt; {        const ModelName = require(&#39;inflection&#39;).classify(req.params.resource)        console.log(req)        req.Model = require(`../models/${ModelName}`)        next()    }}</code></pre><p>通过express的Router，将接口定义为</p><pre><code class="javascript">const resource = require(&#39;../middle/resource&#39;)app.use(&#39;/api/:resource&#39;, resource(), router)</code></pre><p>这样在请求不同资源时，后端就会动态的访问对应的资源，如下面的请求</p><pre><code class="javascript">async getInfo() {  const res = await this.$http.get(&quot;/api/users&quot;);  this.account = res.data;},</code></pre><p>表示获取User的数据。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>express</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CommonJs和ES6模块导入导出</title>
    <link href="/2020/05/05/CommonJs%E5%92%8CES6%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <url>/2020/05/05/CommonJs%E5%92%8CES6%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>学习WebPack工具的一些前端基础，这是web前端系列的第一篇文章。</p><a id="more"></a><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><pre><code class="javascript">//导出//test.js//方式1module.exports = {  name:&#39;module1&#39;,  add: function(a,b){    return a + b  }}//方式2exports.name = &#39;module1&#39;;exports.add = function(a,b){  return a + b}//导入//index.js//方式1const test = require(&#39;./test.js&#39;)const add = test.add//方式2，支持表达式动态导入const modules = [&#39;test.js&#39;,&#39;test2.js&#39;]modules.forEach(name=&gt;{  require(&#39;./&#39;+name)})</code></pre><p>CommonJS注意的地方</p><blockquote><ul><li>在实际使用中，为了提高可读性，建议将module.exports和exports语法语句放在模块最后</li><li>exports指向module.exports，因此不要直接给exports对象赋值，否则会导致module.exports导出失效</li><li>require语句在一个js文件中只<strong>执行一次</strong>，重复使用不会再执行导入模块中的语句</li><li>每个模块都有自己的作用域</li><li>CommonJs导入模块是对其值的拷贝，可以进行修改，不影响原模块</li></ul></blockquote><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><pre><code class="javascript">//导出//test.js//方式1，默认导出，只有一个exportexport dufault {  name:&#39;test&#39;,  add:function(a,b){    return a + b  }}//方式2export const name = &#39;test&#39;export add=function(a,b){  return a+b}//方式3，默认导出const name = &#39;test&#39;add = function(a,b){  return a+b}export {test,add}//方式3，命名导出const name = &#39;test&#39;add = function(a,b){  return a+b}export {test as test1,add as add1}//导入//index.js//方式1，按照原名导入import {name,add} from &#39;./test.js&#39;//方式2，命名导入import {name as name1, add as add1} from &#39;./test.js&#39;//方式3 整体导入import * from &#39;./test.js&#39;//方式4，对默认导出的导入import myModule from &#39;./test.js&#39; //相当于import default as myModule from &#39;./test.js&#39;</code></pre><p>ES6注意的地方</p><blockquote><ul><li>每个模块有自身的作用域</li><li>所有导入的变量都是原模块的动态映射，是只读的，不可以对其进行修改</li><li>对于默认导出来说，导入可以接自定义变量名</li><li>导出、导出必须放在顶层作用域</li></ul></blockquote><h4 id="CommonJS和ES6的区别"><a href="#CommonJS和ES6的区别" class="headerlink" title="CommonJS和ES6的区别"></a>CommonJS和ES6的区别</h4><ul><li>CommonJS对模块依赖的解决是动态的，模块依赖关系的建立发生在代码<strong>运行</strong>阶段。ES6对模块依赖解决的办法是静态的，模块依赖关系的建立发生在代码<strong>编译</strong>阶段</li><li>CommonJS支持导入的路径是表达式，ES6的导入是声明式的，故不支持</li><li>ES6的好处<ul><li>死代码检测和排除</li><li>模块变量类型检查</li><li>编译器优化</li><li>可以利用ES6的特性解决循环依赖问题</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>CommonJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派搭建NCS2环境并测试</title>
    <link href="/2020/03/05/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BANCS2%E7%8E%AF%E5%A2%83%E5%B9%B6%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/03/05/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BANCS2%E7%8E%AF%E5%A2%83%E5%B9%B6%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>做毕设和一些实验的基础，在树莓派环境搭建NCS2的依赖环境并进行相关测试</p><a id="more"></a><h3 id="OpenVINO-toolkit-for-RaspberryPi-树莓派NCS2环境搭建"><a href="#OpenVINO-toolkit-for-RaspberryPi-树莓派NCS2环境搭建" class="headerlink" title="OpenVINO toolkit for RaspberryPi(树莓派NCS2环境搭建)"></a>OpenVINO toolkit for RaspberryPi(树莓派NCS2环境搭建)</h3><p>@Nickname4th 2019/10/01</p><p>Call me at: 1733****598</p><h3 id="烧写官方镜像"><a href="#烧写官方镜像" class="headerlink" title="烧写官方镜像"></a>烧写官方镜像</h3><ul><li>使用BleanEtchar，略</li></ul><h3 id="TensorFlow配置"><a href="#TensorFlow配置" class="headerlink" title="TensorFlow配置"></a>TensorFlow配置</h3><h4 id="更换apt和pip源"><a href="#更换apt和pip源" class="headerlink" title="更换apt和pip源"></a>更换apt和pip源</h4><pre><code class="shell">sudo vim /etc/apt/sources.list</code></pre><blockquote><p>注释原来的源，添加 </p><p>deb <a href="http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a> stretch main contrib non-free rpi<br>deb-src <a href="http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a> stretch main contrib non-free rpi</p></blockquote><pre><code class="shell">pip install pippip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</code></pre><h4 id="安装matplot-使用VNC调试更直观，后续可注释相关代码并以CLI启动"><a href="#安装matplot-使用VNC调试更直观，后续可注释相关代码并以CLI启动" class="headerlink" title="安装matplot(使用VNC调试更直观，后续可注释相关代码并以CLI启动)"></a>安装matplot(使用VNC调试更直观，后续可注释相关代码并以CLI启动)</h4><pre><code class="shell">sudo pip3 install matplotlib</code></pre><h4 id="安装TensorFlow"><a href="#安装TensorFlow" class="headerlink" title="安装TensorFlow"></a>安装TensorFlow</h4><pre><code class="shell">sudo pip3 install tensorflow</code></pre><blockquote><p>安装依赖包时出现报错时将报错的依赖包单独使用sudo pip3 install [包名]即可</p></blockquote><ul><li>安装第三方whl</li></ul><blockquote><p>集成了TensorFlow的api，可以快速测试一个模型</p><pre><code class="shell">sudo pip3 install obapi-1.0.0-py3-none-any.whl</code></pre><p>感谢作者@obapi</p></blockquote><ul><li><p>根据代码移入模型相关文件夹和TensorFlow相关文件夹并修改路径</p><blockquote><p>这里主要是object_detection和silm文件夹等</p></blockquote></li></ul><h4 id="安装opencv及其依赖"><a href="#安装opencv及其依赖" class="headerlink" title="安装opencv及其依赖"></a>安装opencv及其依赖</h4><pre><code class="shell">sudo pip3 install opencv-pythonsudo apt-get install libcblas-devsudo apt-get install libhdf5-devsudo apt-get install libhdf5-serial-devsudo apt-get install libatlas-base-devsudo apt-get install libjasper-dev sudo apt-get install libqtgui4 sudo apt-get install libqt4-test</code></pre><blockquote><p>由于树莓派官方系统更新，可能会因为依赖冲突发生多次错误，耐心按照apt的报错决定是否覆盖安装相关依赖包</p></blockquote><h3 id="TensorFlow模型转换及前后性能测试"><a href="#TensorFlow模型转换及前后性能测试" class="headerlink" title="TensorFlow模型转换及前后性能测试"></a>TensorFlow模型转换及前后性能测试</h3><ul><li><p><a href="https://software.intel.com/en-us/openvino-toolkit/choose-download/free-download-macos" target="_blank" rel="noopener">下载最新版本的macOS*的工具箱OpenVINO toolkit</a>，记住激活码</p></li><li><p>按照<a href="https://docs.openvinotoolkit.org/latest/_docs_install_guides_installing_openvino_macos.html" target="_blank" rel="noopener">官网说明</a>进行配置</p></li><li><p>本次使用冻结模型ssdlite_mobilenet_v2_coco_2018_05_09(官网发现他正好是受支持的拓扑结构)</p></li><li><p>下载模型，将其转换成IR中间件表示</p><ul><li><a href="http://download.tensorflow.org/models/object_detection/ssdlite_mobilenet_v2_coco_2018_05_09.tar.gz" target="_blank" rel="noopener">下载传送门</a></li><li>开始模型转换，<a href="https://docs.openvinotoolkit.org/latest/_docs_MO_DG_prepare_model_convert_model_Convert_Model_From_TensorFlow.html" target="_blank" rel="noopener">转换指南</a></li><li>得到.xml和.bin文件</li><li>修改程序进行对比</li></ul></li></ul><h4 id="TestWithOutNCS2-py"><a href="#TestWithOutNCS2-py" class="headerlink" title="TestWithOutNCS2.py"></a>TestWithOutNCS2.py</h4><blockquote><p>这里就是之前在导盲杖和MacBook Pro上跑的目标检测算法</p></blockquote><pre><code class="python">import numpy as npimport sysimport tensorflow as tffrom obapi import label_map_utilfrom obapi import visualization_utils as vis_utilfrom PIL import Image# import matplotlib.pyplot as pltimport timesys.path.append(&#39;/home/pi/NCS2/object_detection&#39;) # point to your tensorflow dirsys.path.append(&#39;/home/pi/NCS2/slim&#39;) # point ot your slim dir# What model to download.MODEL_NAME = &#39;/home/pi/NCS2/object_detection/&#39;PATH_TO_CKPT = MODEL_NAME + &#39;/frozen_inference_graph.pb&#39;PATH_TO_LABELS = &#39;/home/pi/NCS2/obj/data/mscoco_label_map.pbtxt&#39;NUM_CLASSES = 90detection_graph = tf.Graph()with detection_graph.as_default():  od_graph_def = tf.GraphDef()  with tf.gfile.GFile(PATH_TO_CKPT, &#39;rb&#39;) as fid:    serialized_graph = fid.read()    od_graph_def.ParseFromString(serialized_graph)    tf.import_graph_def(od_graph_def, name=&#39;&#39;)#Loading label maplabel_map = label_map_util.load_labelmap(PATH_TO_LABELS)categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=True)category_index = label_map_util.create_category_index(categories)#Helper codedef load_image_into_numpy_array(image):  (im_width, im_height) = image.size  return np.array(image.getdata()).reshape(      (im_height, im_width, 3)).astype(np.uint8)TEST_IMAGE_PATHS = [&#39;/home/pi/NCS2/obj/test_images/1.jpg&#39;]# Size, in inches, of the output images.IMAGE_SIZE = (16, 9)with detection_graph.as_default():  with tf.Session(graph=detection_graph) as sess:    image_tensor = detection_graph.get_tensor_by_name(&#39;image_tensor:0&#39;)    detection_boxes = detection_graph.get_tensor_by_name(&#39;detection_boxes:0&#39;)    detection_scores = detection_graph.get_tensor_by_name(&#39;detection_scores:0&#39;)    detection_classes = detection_graph.get_tensor_by_name(&#39;detection_classes:0&#39;)    num_detections = detection_graph.get_tensor_by_name(&#39;num_detections:0&#39;)    import cv2    while 1:        for image_path in TEST_IMAGE_PATHS:            start = time.clock()            cap = cv2.VideoCapture(0)            ret, frame = cap.read()            cv2.imwrite(&quot;/home/pi/NCS2/obj/test_images/1.jpg&quot;, frame)            cap.release()            image = Image.open(image_path)            image_np = load_image_into_numpy_array(image)            image_np_expanded = np.expand_dims(image_np, axis=0)            image_tensor = detection_graph.get_tensor_by_name(&#39;image_tensor:0&#39;)            boxes = detection_graph.get_tensor_by_name(&#39;detection_boxes:0&#39;)            scores = detection_graph.get_tensor_by_name(&#39;detection_scores:0&#39;)            classes = detection_graph.get_tensor_by_name(&#39;detection_classes:0&#39;)            num_detections = detection_graph.get_tensor_by_name(&#39;num_detections:0&#39;)            # Actual detection.            (boxes, scores, classes, num_detections) = sess.run(                [boxes, scores, classes, num_detections],                feed_dict={image_tensor: image_np_expanded})            # Visualization of the results of a detection.            vis_util.visualize_boxes_and_labels_on_image_array(                image_np,                np.squeeze(boxes),                np.squeeze(classes).astype(np.int32),                np.squeeze(scores),                category_index,                use_normalized_coordinates=True,                line_thickness=8)            a = np.squeeze(classes).astype(np.int32)[0]            elapsed = (time.clock() - start)            name = category_index[a][&#39;name&#39;]            print(&quot;This is a &quot;,name)            print(&quot;Time used:&quot;,elapsed)            # plt.figure(figsize=IMAGE_SIZE)            # plt.imshow(image_np)            # plt.show()</code></pre><ul><li>冷启动时间：20.6s</li><li>单独进行一次图像识别时间：6.03s</li></ul><h4 id="TestWithNCS2-py"><a href="#TestWithNCS2-py" class="headerlink" title="TestWithNCS2.py"></a>TestWithNCS2.py</h4><blockquote><p>这里是将原来的目标检测算法转换后，通过计算棒执行的目标检测</p></blockquote><pre><code class="shell">cd object_detection-masterpython3 main.py -d MYRIAD -i &quot;cam&quot; -m &quot;ssd_v2.xml&quot; # 使用摄像头进行实时目标检测 python3 main.py  -d MYRIAD -i &quot;Cars - 1900.mp4&quot; -m &quot;./mobilenet-ssd/FP32/mobilenet-ssd.xml&quot; # 在测试视频中运行目标检测</code></pre><blockquote><p>注意：通过ssh进行目标检测时，会由于无法调用display而报错，这里将cv2.imshow()注释即可，如果要观测，可以通过VNC连接至树莓派，通过内置终端执行语句</p><p>object_detection-master文件夹资源链接：<a href="https://yaleedupl-my.sharepoint.com/:f:/g/personal/acs_shier_love/Eu6GMrDyxi9DkFD4rAKy6-ABjpyvwmHuBWWkQRijtCo4rQ?e=zr7eIA" target="_blank" rel="noopener">https://yaleedupl-my.sharepoint.com/:f:/g/personal/acs_shier_love/Eu6GMrDyxi9DkFD4rAKy6-ABjpyvwmHuBWWkQRijtCo4rQ?e=zr7eIA</a></p></blockquote><pre><code class="python">#main.py代码from __future__ import print_functionimport sysimport osfrom argparse import ArgumentParserimport cv2import timeimport logging as logimport numpy as npimport ioimport detect as dtfrom openvino.inference_engine import IENetwork, IEPluginfrom pathlib import Pathsys.path.insert(0, str(Path().resolve().parent.parent))def build_argparser():    parser = ArgumentParser()    parser.add_argument(&quot;-m&quot;, &quot;--model&quot;, help=&quot;Path to an .xml file with a trained model.&quot;, required=True, type=str)    parser.add_argument(&quot;-i&quot;, &quot;--input&quot;,                        help=&quot;Path to video file or image. &#39;cam&#39; for capturing video stream from camera&quot;,                        type=str)    parser.add_argument(&quot;-l&quot;, &quot;--cpu_extension&quot;,                        help=&quot;MKLDNN (CPU)-targeted custom layers.Absolute path to a shared library with the kernels &quot;                             &quot;impl.&quot;, type=str, default=None)    parser.add_argument(&quot;-pp&quot;, &quot;--plugin_dir&quot;, help=&quot;Path to a plugin folder&quot;, type=str, default=None)    parser.add_argument(&quot;-d&quot;, &quot;--device&quot;,                        help=&quot;Specify the target device to infer on; CPU, GPU, FPGA, MYRIAD or HDDL is acceptable. Sample &quot;                             &quot;will look for a suitable plugin for device specified (CPU by default)&quot;, default=&quot;CPU&quot;,                        type=str)    parser.add_argument(&quot;--labels&quot;, help=&quot;Labels mapping file&quot;, default=None, type=str)    parser.add_argument(&quot;-pt&quot;, &quot;--prob_threshold&quot;, help=&quot;Probability threshold for detections filtering&quot;,                        default=0.5, type=float)    parser.add_argument(&quot;-o&quot;, &quot;--output_dir&quot;, help=&quot;If set, it will write a video here instead of displaying it&quot;,                        default=None, type=str)    return parserdef make_sure_path_exists(path):    try:        os.makedirs(path)    except OSError as exception:        passdef main():    is_async_mode = True    args = build_argparser().parse_args()    object_detection=dt.Detectors(args.device,args.model,args.cpu_extension,args.plugin_dir,is_async_mode)    resultant_initialisation_object=object_detection.initialise_inference()    input_stream = args.input    cap = cv2.VideoCapture(0)    ret, frame = cap.read()    cv2.imwrite(&quot;/home/pi/NCS2/obj/test_images/1.jpg&quot;, frame)    video_len = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))    frame_width = int(cap.get(3))    frame_height = int(cap.get(4))    cur_request_id = 0    next_request_id = 1    try:        while cap.isOpened():            start = time.clock()            ret, frame = cap.read()            if not ret:                break            initial_w = cap.get(3)            initial_h = cap.get(4)            res_inference=resultant_initialisation_object.process_frame(cur_request_id,next_request_id,frame,initial_h,initial_w,False)            resultant_frame=resultant_initialisation_object.placeBoxes(res_inference,None,0.5,frame,initial_w,initial_h,False,cur_request_id)            key = cv2.waitKey(1)            if key == 27:                break            elapsed = (time.clock() - start)            print(&quot;Time used:&quot;,elapsed)        cap.release()    finally:        del resultant_initialisation_object.exec_netif __name__ == &#39;__main__&#39;:    sys.exit(main() or 0)</code></pre><ul><li>冷启动时间：2.0s</li><li>单独进行一次图像识别时间：0.06s</li></ul><h3 id="RealTime的性能对比"><a href="#RealTime的性能对比" class="headerlink" title="RealTime的性能对比"></a>RealTime的性能对比</h3><blockquote><p>相同场景下实时识别，对比帧数</p></blockquote><p>待续。。。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NCS2</tag>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨年旅行计划</title>
    <link href="/2019/12/06/%E8%B7%A8%E5%B9%B4%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2019/12/06/%E8%B7%A8%E5%B9%B4%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>2019-2020跨年旅行计划，实际过程略有差别。</p><a id="more"></a><h2 id="旅行规划"><a href="#旅行规划" class="headerlink" title="旅行规划"></a>旅行规划</h2><blockquote><p>@Nickname4th @是这个zhang馨</p></blockquote><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li>📅2019年12月27日-2020年1月1日<ul><li>2019年12月28日凌晨01:30分小仙女🧚‍♀️抵达美兰机场✈️</li><li>2020年1月1日晚上23:30分一起回家</li></ul></li></ul><h4 id="物资筹备"><a href="#物资筹备" class="headerlink" title="物资筹备"></a>物资筹备</h4><ul><li>穿<ul><li>可爱的小裙裙裙👗</li><li>可爱或酷的鞋👢</li><li>御寒的外套🧥</li><li>游泳的👙</li><li>私人物品</li></ul></li><li>旅行用品<ul><li>Canon M6📷</li><li>iPhone 11 📱</li><li>学生证👩‍🎓👨‍🎓</li><li>非常规必备化妆系列<ul><li>防晒霜🧴</li><li>补水💦</li></ul></li><li>Money💰</li></ul></li><li>为了回家<ul><li>羽绒服</li><li>围巾🧣</li><li>等防寒物品</li></ul></li></ul><h4 id="路线和时间"><a href="#路线和时间" class="headerlink" title="路线和时间"></a>路线和时间</h4><table><thead><tr><th align="center">时间</th><th align="center">地点</th><th align="center">项目</th></tr></thead><tbody><tr><td align="center">12.28</td><td align="center">观澜湖冯小刚电影公社、蜡像馆</td><td align="center"></td></tr><tr><td align="center">12.29</td><td align="center">南山寺、天涯海角、鹿回头</td><td align="center"></td></tr><tr><td align="center">12.30</td><td align="center">蜈支洲岛、椰梦长廊</td><td align="center"></td></tr><tr><td align="center">12.31</td><td align="center">亚龙湾天堂森林公园、玻璃栈道、玫瑰谷森林公园</td><td align="center"></td></tr></tbody></table><ul><li>12.28 海口 观澜湖华谊冯小刚电影公社🎬     观澜湖矿物质温泉主题公园⛲️<ul><li>海口东站——观澜湖<ul><li>1942民国街</li><li>南洋街</li><li>芳华小院</li><li>海洋馆🐬</li><li>名人蜡像馆</li><li>温泉♨️</li></ul></li><li>傍晚：海口东站——三亚🚄</li><li>住：三亚湾（待定）</li></ul></li><li>12.29 三亚 三亚湾<ul><li>南山寺<ul><li>南海观音</li></ul></li><li>鹿回头🦌</li><li>天涯海角</li></ul></li><li>12.30 三亚 亚龙湾<ul><li>亚龙湾热带天堂森林公园<ul><li>玻璃栈道</li><li>环游</li></ul></li><li>玫瑰谷森林公园</li><li>三亚千古情</li></ul></li><li>12.31 三亚 蜈支洲岛 <ul><li>槟榔谷</li><li>五指山漂流</li><li>凤凰岛酒店天空酒廊（待定）</li></ul></li><li>1.1海口 小刘的大学生活体验🏫<ul><li>海口东站——海南大学<ul><li>南门第一家清补凉🥗</li><li>校车🚌参观小刘平时呆的地方</li></ul></li><li>美兰机场✈️——成都双流</li></ul></li></ul><h4 id="Something"><a href="#Something" class="headerlink" title="Something"></a>Something</h4><ul><li><input disabled="" type="checkbox"> 在某个海边或高处🏖看日落</li><li><input checked="" disabled="" type="checkbox"> 一起吹吹风</li><li><input disabled="" type="checkbox"> 拍一张落日时分的剪影</li><li><input checked="" disabled="" type="checkbox"> 在某个海鲜市场寻找小张心心念的螃蟹🦀</li><li><input disabled="" type="checkbox"> 带上漂流瓶许一个愿望</li></ul><h4 id="预算和经费"><a href="#预算和经费" class="headerlink" title="预算和经费"></a>预算和经费</h4><ul><li><p>机票🛫</p><ul><li>小张来回 ￥2240</li><li>小刘回     ￥800</li></ul></li><li><p>车马费🐴</p></li></ul><ul><li><p>吃喝玩乐🍲</p></li><li><p>住宿🏡</p></li><li><p>纪念品🎁</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>个人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
      <tag>纪念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
