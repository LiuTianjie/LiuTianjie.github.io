<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于Vue和MQTT的简单IOT系统</title>
    <link href="/2020/05/13/%E5%9F%BA%E4%BA%8EVue%E5%92%8CMQTT%E7%9A%84%E7%AE%80%E5%8D%95IOT%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/05/13/%E5%9F%BA%E4%BA%8EVue%E5%92%8CMQTT%E7%9A%84%E7%AE%80%E5%8D%95IOT%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>最近有个同学有点需求，简单帮忙实现了一下，前端部分使用了Vue+ElementUI，后端部分使用了MongoDB，中间使用MQTT协议的“发布——订阅”模式实现消息的传递。之前使用Docker在腾讯云搭建了一个环境，传送门<a href="https://github.com/LiuTianjie/zc_web" target="_blank" rel="noopener">A lot project build with Vue and Docker</a>，如果你没有docker的相关知识，可以直接查看代码的web和server文件夹即可。</p><a id="more"></a><h2 id="基于Vue和MQTT的简单IOT系统"><a href="#基于Vue和MQTT的简单IOT系统" class="headerlink" title="基于Vue和MQTT的简单IOT系统"></a>基于Vue和MQTT的简单IOT系统</h2><img src="http://images.nickname4th.vip/zc_bb.png" srcset="/img/loading.gif" alt="zc_bb" style="zoom: 25%;" /><p>整个系统可以分为前端、后端和硬件三个部分，前端通过模拟购票和开锁与后端数据库交互，并通过MQTT协议与树莓派通信，树莓派控制GPIO信号控制IOT设备。</p><h3 id="1-前端部分"><a href="#1-前端部分" class="headerlink" title="1 前端部分"></a>1 前端部分</h3><h4 id="1-1-全局http处理"><a href="#1-1-全局http处理" class="headerlink" title="1.1 全局http处理"></a>1.1 全局http处理</h4><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">const</span> http = axios.create(&#123;    baseURL: <span class="hljs-string">'url'</span>&#125;)http.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> res&#125;, err =&gt; &#123;    <span class="hljs-comment">//服务端返回错误通用处理方案，并使用element的message进行提示</span>    <span class="hljs-keyword">if</span> (err.response.data) &#123;        Vue.prototype.$message.error(&#123;            type: <span class="hljs-string">'error'</span>,            message: err.response.data        &#125;);        <span class="hljs-built_in">console</span>.log(err.response.status)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> http</code></pre><p>使用axios进行网络请求，添加http拦截器，将服务端返回的错误码和信息返回。</p><h4 id="1-2-模拟购票"><a href="#1-2-模拟购票" class="headerlink" title="1.2 模拟购票"></a>1.2 模拟购票</h4><p>简单的表单验证，利用vue的ref引用一个p标签来展示购票结果。</p><pre><code class="hljs vue">&lt;div class&#x3D;&quot;buy&quot; v-loading.fullscreen.lock&#x3D;&quot;loading&quot;&gt;  &lt;el-card header&#x3D;&quot;购买车票（模拟）&quot; class&#x3D;&quot;check-card&quot;&gt;    &lt;div class&#x3D;&quot;info&quot;&gt;      &lt;p ref&#x3D;&quot;answer&quot;&gt;&lt;&#x2F;p&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;el-card&gt;&lt;&#x2F;div&gt;&lt;script&gt;methods: &#123;    check() &#123;      let that &#x3D; this;      this.$refs[&quot;formData&quot;].validate(async valid &#x3D;&gt; &#123;        if (valid) &#123;          this.$refs.answer.innerHTML &#x3D; &quot;购票中，请稍后&quot;;          this.loading &#x3D; true;          try &#123;            const res &#x3D; await this.$http.post(&quot;&#x2F;orders&quot;, this.formData);            setTimeout(() &#x3D;&gt; &#123;              this.loading &#x3D; false;              this.$message(&#123;                message: &quot;购票成功！&quot;,                type: &quot;success&quot;              &#125;);            &#125;, 500);            this.resetForm(&quot;formData&quot;);            this.$refs.answer.innerHTML &#x3D; &#96;购票成功！&lt;&#x2F;p&gt;&lt;p&gt;          日期：$&#123;res.data.date&#125;&lt;&#x2F;p&gt;&lt;p&gt;          车次：$&#123;res.data.train&#125;&lt;&#x2F;p&gt;&lt;p&gt;          座位：$&#123;res.data.set&#125;&#96;;          &#125; catch (err) &#123;            setTimeout(() &#x3D;&gt; &#123;              this.loading &#x3D; false;              this.$refs.answer.innerHTML &#x3D; &quot;购票失败！&quot;;            &#125;, 500);          &#125;        &#125; else &#123;          this.$message.error(&quot;输入有误，请重试！&quot;);        &#125;      &#125;);    &#125;,&#125;&lt;&#x2F;script&gt;</code></pre><ul><li>使用了v-loading做等待时的缓冲动画</li><li>利用ref控制购票状态</li></ul><h4 id="1-2-模拟验证"><a href="#1-2-模拟验证" class="headerlink" title="1.2 模拟验证"></a>1.2 模拟验证</h4><pre><code class="hljs vue">&lt;el-form :model&#x3D;&quot;formData&quot; ref&#x3D;&quot;formData&quot; label-width&#x3D;&quot;100px&quot; @submit.native.prevent&#x3D;&quot;check&quot;&gt;  &lt;el-form-item    label&#x3D;&quot;身份证号&quot;    prop&#x3D;&quot;id&quot;    :rules&#x3D;&quot;[              &#123; required: true, message: &#39;身份证号码不能为空&#39;&#125;,              &#123; required: true, message: &#39;请填写证件号码&#39;, trigger: &#39;blur&#39; &#125;,              &#123; pattern: &#x2F;(^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\d&#123;5&#125;\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;2&#125;$)&#x2F;,                message: &#39;证件号码格式有误！&#39;,                trigger: &#39;blur&#39;              &#125;]&quot;&gt;    &lt;el-input      class&#x3D;&quot;check-box&quot;      type&#x3D;&quot;id&quot;      v-model&#x3D;&quot;formData.id&quot;      autocomplete&#x3D;&quot;off&quot;      placeholder&#x3D;&quot;请输入身份证号码&quot;&gt;    &lt;&#x2F;el-input&gt;  &lt;&#x2F;el-form-item&gt;     &lt;el-button type&#x3D;&quot;primary&quot; native-type&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;el-button&gt;     &lt;el-button @click&#x3D;&quot;resetForm(&#39;formData&#39;)&quot;&gt;重置&lt;&#x2F;el-button&gt;   &lt;&#x2F;el-form-item&gt;&lt;&#x2F;el-form&gt;</code></pre><ul><li>使用element表单验证，rules中使用正则表达式限制身份证号码的格式</li><li>@submit.native.prevent=”check”，阻止表单的自动提交</li><li>提交按钮绑定native-type=”submit”，点击提交</li></ul><h3 id="2-后端部分"><a href="#2-后端部分" class="headerlink" title="2 后端部分"></a>2 后端部分</h3><h4 id="2-1-MQTT-Server"><a href="#2-1-MQTT-Server" class="headerlink" title="2.1 MQTT Server"></a>2.1 MQTT Server</h4><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mosca = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mosca'</span>);<span class="hljs-comment">//构建自带服务器</span><span class="hljs-keyword">var</span> MqttServer = <span class="hljs-keyword">new</span> mosca.Server(&#123;    port: <span class="hljs-number">1883</span>&#125;);<span class="hljs-comment">//对服务器端口进行配置， 在此端口进行监听</span>MqttServer.on(<span class="hljs-string">'clientConnected'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">client</span>) </span>&#123;    <span class="hljs-comment">//监听连接</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'client connected'</span>, client.id);&#125;);<span class="hljs-comment">/**</span><span class="hljs-comment"> * 监听MQTT主题消息</span><span class="hljs-comment"> **/</span>MqttServer.on(<span class="hljs-string">'published'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">packet, client</span>) </span>&#123;    <span class="hljs-comment">//当客户端有连接发布主题消息</span>    <span class="hljs-keyword">var</span> topic = packet.topic;    <span class="hljs-built_in">console</span>.log(packet);    <span class="hljs-keyword">switch</span> (topic) &#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">'train1'</span>:            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'message-publish'</span>, packet.payload.toString());            <span class="hljs-comment">//MQTT转发主题消息</span>            <span class="hljs-comment">//MqttServer.publish(&#123; topic: 'other', payload: 'sssss' &#125;);</span>            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-string">'train2'</span>:            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'message-123'</span>, packet.payload.toString());            <span class="hljs-keyword">break</span>;    &#125;&#125;);MqttServer.on(<span class="hljs-string">'ready'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">//当服务开启时</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'mqtt is running...'</span>);&#125;);</code></pre><ul><li>通过mosca新建mqtt服务器，监听1883端口</li><li>利用switch函数，监听从客户的publish的消息</li></ul><h4 id="2-2-Express服务器接口"><a href="#2-2-Express服务器接口" class="headerlink" title="2.2 Express服务器接口"></a>2.2 Express服务器接口</h4><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Model = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../models/Order'</span>)<span class="hljs-keyword">const</span> mqtt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mqtt'</span>);<span class="hljs-keyword">const</span> client = mqtt.connect(<span class="hljs-string">'mqtt://host'</span>); <span class="hljs-comment">//连接到服务端</span><span class="hljs-comment">//验证并删除订单记录</span>router.get(<span class="hljs-string">'/orders/:id'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;  <span class="hljs-keyword">const</span> item = <span class="hljs-keyword">await</span> Model.findOne(&#123; <span class="hljs-attr">user</span>: req.params.id &#125;)  <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">null</span>) &#123;    res.status(<span class="hljs-number">401</span>).send(<span class="hljs-string">"未查到数据！"</span>)  &#125;  <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">const</span> id = item._id    <span class="hljs-built_in">console</span>.log(item)    <span class="hljs-keyword">const</span> msg = <span class="hljs-keyword">await</span> Model.findOneAndDelete(&#123; <span class="hljs-attr">_id</span>: id &#125;)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"使用成功！已删除！"</span>)    res.send(item)    client.publish(<span class="hljs-string">'train1'</span>, msg.set+<span class="hljs-string">''</span>, &#123; <span class="hljs-attr">qos</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">retain</span>: <span class="hljs-literal">true</span> &#125;);  &#125;&#125;)</code></pre><ul><li>使用express的router定义后端路由，通过url传递参数匹配特定用户的id，进行CURD操作</li><li>创建mqtt客户端，删除时向“train1”频道发布信息</li></ul><h3 id="3-硬件部分"><a href="#3-硬件部分" class="headerlink" title="3 硬件部分"></a>3 硬件部分</h3><h4 id="3-1-示意图和电路图"><a href="#3-1-示意图和电路图" class="headerlink" title="3.1 示意图和电路图"></a>3.1 示意图和电路图</h4><ul><li>示意图</li></ul><img src="http://images.nickname4th.vip/zc_bb.png" srcset="/img/loading.gif" alt="zc_bb" style="zoom: 25%;" /><ul><li>电路图</li></ul><img src="http://images.nickname4th.vip/zc_图示.png" srcset="/img/loading.gif" alt="zc_图示" style="zoom:25%;" /><ul><li><p>GPIO 11 连接至L298N驱动板的ENA，用于发送高低电平信号，GPIO 35、36连接L298N的IN1、IN2，用于控制OUT1的输出，L298N真值表如下：</p><table><thead><tr><th align="center">ENA</th><th align="center">IN1</th><th align="center">IN2</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">x</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">+12V</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">-12V</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table></li></ul><h4 id="3-2-MQTT-Client"><a href="#3-2-MQTT-Client" class="headerlink" title="3.2 MQTT Client"></a>3.2 MQTT Client</h4><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mqtt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mqtt'</span>);<span class="hljs-comment">//指定服务端地址和端口</span><span class="hljs-keyword">var</span> client2 = mqtt.connect(<span class="hljs-string">"host:1883"</span>);<span class="hljs-comment">//引入Node.js操作GPIO的库</span><span class="hljs-keyword">var</span> rpio = <span class="hljs-built_in">require</span>(<span class="hljs-string">'rpio'</span>);<span class="hljs-keyword">const</span> player = <span class="hljs-built_in">require</span>(<span class="hljs-string">'play-sound'</span>)();rpio.open(<span class="hljs-number">12</span>, rpio.OUTPUT);rpio.open(<span class="hljs-number">35</span>, rpio.OUTPUT, rpio.HIGH);rpio.open(<span class="hljs-number">36</span>, rpio.OUTPUT, rpio.LOW);<span class="hljs-comment">//MQTT客户端订阅主题train1</span>client2.subscribe(<span class="hljs-string">'train1'</span>, &#123; <span class="hljs-attr">qos</span>: <span class="hljs-number">1</span> &#125;);<span class="hljs-comment">//订阅主题为train1的消息  </span><span class="hljs-comment">//当客户端收到消息时，在控制台输出消息内容，</span>client2.on(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">top, message</span>) </span>&#123;  <span class="hljs-comment">//收到验证信息后，验证</span>  rpio.write(<span class="hljs-number">11</span>, rpio.HIGH);  rpio.msleep(<span class="hljs-number">800</span>)  rpio.write(<span class="hljs-number">11</span>, rpio.LOW);  <span class="hljs-built_in">console</span>.log(message.toString() + <span class="hljs-string">'号锁已开启！'</span>);  player.play(<span class="hljs-string">'./open.mp3'</span>, (err) =&gt; &#123;    <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Could not play sound: <span class="hljs-subst">$&#123;err&#125;</span>`</span>);  &#125;);  setTimeout(player.play(<span class="hljs-string">'./close.mp3'</span>, (err) =&gt; &#123;    <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Could not play sound: <span class="hljs-subst">$&#123;err&#125;</span>`</span>);  &#125;), <span class="hljs-number">100000</span>)&#125;);</code></pre><ul><li>在<a href="https://www.jianshu.com/p/5cf4df8806c0" target="_blank" rel="noopener">树莓派配置好Node环境</a>，安装MQTT协议的库，订阅相应的主题，在客户端发起对物联网设备的操作请求时，在通过校验后，即可进行相应的操作</li><li>可以根据订阅消息的具体内容再进一步判断操作，但是注意消息内容仅能以字符串形式传递。</li></ul>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>MQTT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Vue和Express的登录注册系统</title>
    <link href="/2020/05/07/%E5%9F%BA%E4%BA%8EVue%E5%92%8CExpress%E7%9A%84%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/05/07/%E5%9F%BA%E4%BA%8EVue%E5%92%8CExpress%E7%9A%84%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>这是一个简单的登录注册示例，包含了登录、注册和用户页面三个部分。本示例的代码保存在我的github仓库，如有不清楚的地方可以下载查阅。<a href="https://github.com/LiuTianjie/LoginSystem" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><h2 id="基于Vue和express的登录注册系统"><a href="#基于Vue和express的登录注册系统" class="headerlink" title="基于Vue和express的登录注册系统"></a>基于Vue和express的登录注册系统</h2><h3 id="1-前端部分"><a href="#1-前端部分" class="headerlink" title="1 前端部分"></a>1 前端部分</h3><h4 id="1-1-UI"><a href="#1-1-UI" class="headerlink" title="1.1 UI"></a>1.1 UI</h4><p>UI方面使用了Element UI的按钮、表单和消息通知等组件。</p><ul><li><p>引入ElementUI</p><pre><code class="hljs shell">vue add element-ui</code></pre></li><li><p>使用ElementUI</p><pre><code class="hljs javascript"><span class="hljs-comment">//element.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> Element <span class="hljs-keyword">from</span> <span class="hljs-string">'element-ui'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'element-ui/lib/theme-chalk/index.css'</span>Vue.use(Element)<span class="hljs-comment">/*这里是全局导入，将ElementUI可用的组件全部挂载到Vue上,</span><span class="hljs-comment">这样我们就可以直接使用其组件了，如Vue.prototype.$message等</span></code></pre></li></ul><h4 id="1-2-网络请求http-js"><a href="#1-2-网络请求http-js" class="headerlink" title="1.2 网络请求http.js"></a>1.2 网络请求http.js</h4><p>前端网络请求使用了axios，通过async—await语法实现异步请求。</p><ul><li><p>引入axios</p><pre><code class="hljs shell">npm install vue-axios</code></pre></li><li><p>配置http.js</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router/index'</span><span class="hljs-keyword">const</span> http = axios.create(&#123;    baseURL: <span class="hljs-string">'http://localhost:3030'</span>&#125;)<span class="hljs-comment">//拦截器</span>http.interceptors.request.use(<span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (localStorage.token) &#123;        config.headers.Authorization = <span class="hljs-string">'Bearer '</span> + localStorage.token    &#125;    <span class="hljs-keyword">return</span> config&#125;)http.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> res&#125;, err =&gt; &#123;  <span class="hljs-comment">//服务器无响应</span>    <span class="hljs-keyword">if</span> (!err.response) &#123;        Vue.prototype.$message.error(&#123;            type: <span class="hljs-string">'error'</span>,            message: <span class="hljs-string">"服务器连接失败"</span>        &#125;);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)    &#125;    <span class="hljs-comment">//服务端返回错误通用处理方案</span>    <span class="hljs-keyword">if</span> (err.response.data.message) &#123;        Vue.prototype.$message.error(&#123;            type: <span class="hljs-string">'error'</span>,            message: err.response.data.message        &#125;);        <span class="hljs-comment">// console.log(err.response.status)</span>        <span class="hljs-keyword">if</span> (err.response.status === <span class="hljs-number">401</span>) &#123;            router.push(<span class="hljs-string">'/login'</span>)        &#125;    &#125;    <span class="hljs-comment">// console.log(err.response.data.message)</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> http</code></pre><p>上述代码进行了如下操作：</p><ul><li><p>配置了请求接口的Baseurl，请求时通过拼接访问具体接口，有利于隐私性。</p></li><li><p>添加了请求拦截器，配合后端的权限机制，在访问需要用户登录后才能使用的页面时，在请求头中添加token，供后端验证。</p></li><li><p>添加了全局错误处理的拦截，配合服务端返回的错误代码和信息，进行相应的展示和跳转，如这里收到服务端401代码则返回登录页面。</p></li><li><p>抛出http模块，在main.js中将其挂载到Vue的原型对象，便于直接通过<strong>this</strong>来使用。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'./plugins/element.js'</span><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'./http'</span>Vue.prototype.$http = httpVue.config.productionTip = <span class="hljs-literal">false</span><span class="hljs-keyword">new</span> Vue(&#123;  router,  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)&#125;).$mount(<span class="hljs-string">'#app'</span>)</code></pre></li></ul></li></ul><h4 id="1-3-前端路由"><a href="#1-3-前端路由" class="headerlink" title="1.3 前端路由"></a>1.3 前端路由</h4><p>使用vue-router实现前端路由。</p><ul><li><p>引入vue-router</p><pre><code class="hljs shell">vue add vue-router --save</code></pre></li><li><p>定义router.js</p><p>本示例中包含3个页面，相应的配置为：</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>Vue.use(VueRouter)<span class="hljs-keyword">const</span> routes = [  &#123;    path: <span class="hljs-string">'/'</span>,    name: <span class="hljs-string">'Login'</span>,    component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "about" */</span> <span class="hljs-string">'../views/Login.vue'</span>),    meta: &#123; <span class="hljs-attr">isPublic</span>: <span class="hljs-literal">true</span> &#125;  &#125;,  &#123;    path: <span class="hljs-string">'/login'</span>,    name: <span class="hljs-string">'Login'</span>,    component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "about" */</span> <span class="hljs-string">'../views/Login.vue'</span>),    meta: &#123; <span class="hljs-attr">isPublic</span>: <span class="hljs-literal">true</span> &#125;  &#125;,  &#123;    path: <span class="hljs-string">'/signup'</span>,    name: <span class="hljs-string">'SignUp'</span>,    component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "about" */</span> <span class="hljs-string">'../views/SignUp.vue'</span>),    meta: &#123; <span class="hljs-attr">isPublic</span>: <span class="hljs-literal">true</span> &#125;  &#125;,  &#123;    path: <span class="hljs-string">'/index:id'</span>,    name: <span class="hljs-string">'index'</span>,    component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "about" */</span> <span class="hljs-string">'../views/index.vue'</span>),    meta: &#123; <span class="hljs-attr">isPublic</span>: <span class="hljs-literal">false</span> &#125;  &#125;,  &#123;    path: <span class="hljs-string">'*'</span>,    name: <span class="hljs-string">'notfound'</span>,    component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "about" */</span> <span class="hljs-string">'../views/notfound.vue'</span>)  &#125;]</code></pre><ul><li><p>通过meta属性限定页面是否公开，配合全局导航守卫进行路由判断。</p></li><li><p>通过’*’路由加入404页面。</p></li></ul></li></ul><h5 id="1-3-1-全局导航守卫"><a href="#1-3-1-全局导航守卫" class="headerlink" title="1.3.1 全局导航守卫"></a>1.3.1 全局导航守卫</h5><pre><code class="hljs javascript">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (!to.meta.isPublic &amp;&amp; !localStorage.token) &#123;    Vue.prototype.$message(&#123;      type: <span class="hljs-string">"warning"</span>,      message: <span class="hljs-string">"请先登录"</span>    &#125;);    next(<span class="hljs-string">'/login'</span>)  &#125;  next()&#125;)</code></pre><p>在页面跳转之前进行相应的判断，主要在非法访问页面时跳转到login页面。</p><h4 id="1-4-登录"><a href="#1-4-登录" class="headerlink" title="1.4 登录"></a>1.4 登录</h4><h5 id="1-4-1-Login-vue"><a href="#1-4-1-Login-vue" class="headerlink" title="1.4.1 Login.vue"></a>1.4.1 Login.vue</h5><pre><code class="hljs vue">&lt;script&gt;export default &#123;  name: &quot;app&quot;,  data() &#123;    return &#123;      form: &#123;        account: &quot;&quot;,        psw: &quot;&quot;      &#125;    &#125;;  &#125;,  components: &#123;&#125;,  methods: &#123;    async toLogin() &#123;      if (this.form.psw &#x3D;&#x3D;&#x3D; &quot;&quot; || this.form.account&#x3D;&#x3D;&#x3D;&quot;&quot;) &#123;        this.$notify(&#123;          title: &quot;输入错误&quot;,          message: &quot;请检查账户和密码！&quot;,          type: &quot;error&quot;        &#125;);      &#125; else &#123;        const res &#x3D; await this.$http.post(&quot;login&quot;, this.form);        localStorage.token &#x3D; res.data.token;        this.$message(&#123;          type: &quot;success&quot;,          message: &quot;登录成功&quot;        &#125;);        this.$router.push(&#123; path: &#96;.&#x2F;index$&#123;this.form.account&#125;&#96; &#125;);      &#125;    &#125;,    toSignUp() &#123;      this.$router.push(&#123; path: &quot;.&#x2F;signup&quot; &#125;);    &#125;  &#125;&#125;;&lt;&#x2F;script&gt;</code></pre><p>通过定义的toLogin方法进行登录，在前端限制了账户和密码非空，并通过Element的message进行提示。通过POST方法将表单数据。</p><h4 id="1-5-注册"><a href="#1-5-注册" class="headerlink" title="1.5 注册"></a>1.5 注册</h4><h5 id="1-5-1-SignUp-vue"><a href="#1-5-1-SignUp-vue" class="headerlink" title="1.5.1 SignUp.vue"></a>1.5.1 SignUp.vue</h5><pre><code class="hljs vue">&lt;script&gt;export default &#123;  methods: &#123;    toLogin() &#123;      this.$router.push(&#123; path: &quot;.&#x2F;login&quot; &#125;);    &#125;,    async toSignUp() &#123;      try &#123;        this.loading &#x3D; true;        const res &#x3D; await this.$http.post(&quot;&#x2F;api&#x2F;users&quot;, this.form);        this.$message(&#123;          type: &quot;success&quot;,          message: &quot;注册成功&quot;        &#125;);        this.loading &#x3D; false;      &#125; catch (error) &#123;        this.$message(&#123;          type: &quot;error&quot;,          message: &quot;注册失败&quot;        &#125;);        this.loading &#x3D; false;      &#125;      this.clear();    &#125;,&lt;&#x2F;script&gt;</code></pre><h5 id="1-5-2-表单验证"><a href="#1-5-2-表单验证" class="headerlink" title="1.5.2 表单验证"></a>1.5.2 表单验证</h5><pre><code class="hljs javascript">data() &#123;  <span class="hljs-comment">//验证用户名</span>  <span class="hljs-keyword">var</span> checkAccount = <span class="hljs-keyword">async</span> (rule, value, callback) =&gt; &#123;    <span class="hljs-keyword">if</span> (value === <span class="hljs-string">""</span>) &#123;      <span class="hljs-keyword">this</span>.accountValid = <span class="hljs-literal">false</span>;      callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"账户不能为空"</span>));    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.$http.get(<span class="hljs-string">`/<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.form.account&#125;</span>`</span>);      <span class="hljs-keyword">if</span> (res.data) &#123;        <span class="hljs-keyword">this</span>.accountValid = <span class="hljs-literal">false</span>;        callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"用户已存在"</span>));      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">this</span>.accountValid = <span class="hljs-literal">true</span>;        callback();      &#125;    &#125;  &#125;;  <span class="hljs-comment">//验证密码1</span>  <span class="hljs-keyword">var</span> checkpsw1 = <span class="hljs-function">(<span class="hljs-params">rule, value, callback</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (value === <span class="hljs-string">""</span>) &#123;      <span class="hljs-keyword">this</span>.psw1Valid = <span class="hljs-literal">false</span>;      callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"密码不能为空"</span>));    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.form.psw1 !== <span class="hljs-string">""</span>) &#123;        <span class="hljs-keyword">this</span>.$refs.form.validateField(<span class="hljs-string">"psw2"</span>);      &#125;      <span class="hljs-keyword">this</span>.psw1Valid = <span class="hljs-literal">true</span>;      callback();    &#125;  &#125;;  <span class="hljs-keyword">var</span> checkpsw2 = <span class="hljs-function">(<span class="hljs-params">rule, value, callback</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (value === <span class="hljs-string">""</span>) &#123;      <span class="hljs-keyword">this</span>.psw2Valid = <span class="hljs-literal">false</span>;      callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"请再次输入密码"</span>));    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value !== <span class="hljs-keyword">this</span>.form.psw1) &#123;      <span class="hljs-keyword">this</span>.psw2Valid = <span class="hljs-literal">false</span>;      callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"两次输入密码不一致!"</span>));    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">this</span>.psw2Valid = <span class="hljs-literal">true</span>;      callback();    &#125;  &#125;;  <span class="hljs-keyword">return</span> &#123;    form: &#123;      account: <span class="hljs-string">""</span>,      psw1: <span class="hljs-string">""</span>,      psw2: <span class="hljs-string">""</span>,      check: <span class="hljs-string">""</span>    &#125;,    loading: <span class="hljs-literal">false</span>,    hasRead: <span class="hljs-literal">false</span>,    accountValid: <span class="hljs-literal">false</span>,    psw1Valid: <span class="hljs-literal">false</span>,    psw2Valid: <span class="hljs-literal">false</span>,    rules: &#123;      account: [&#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">validator</span>: checkAccount, <span class="hljs-attr">trigger</span>: <span class="hljs-string">"blur"</span> &#125;],      psw1: [&#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">validator</span>: checkpsw1, <span class="hljs-attr">trigger</span>: <span class="hljs-string">"blur"</span> &#125;],      psw2: [&#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">validator</span>: checkpsw2, <span class="hljs-attr">trigger</span>: <span class="hljs-string">"blur"</span> &#125;]    &#125;  &#125;;&#125;,&#125;;</code></pre><p>表单验证使用了Element 的表单组件，通过callback函数和rule规则实现。其中触发规则为”blur”。</p><ul><li><p>使用V-model绑定表单的值，通过hasRead等布尔值限制提交。</p></li><li><p>使用了loading组件对注册时的页面进行遮罩。</p></li><li><p>当且仅当5个条件判断的布尔值全部符合条件时，才允许提交注册请求。</p></li><li><p>一次注册成功之后，清除表单数据。</p></li></ul><h3 id="2-后端部分"><a href="#2-后端部分" class="headerlink" title="2 后端部分"></a>2 后端部分</h3><p>后盾的数据库采用MongoDB，通过Node.js的mongoose插件进行数据库的操作。</p><h4 id="2-1登录接口"><a href="#2-1登录接口" class="headerlink" title="2.1登录接口"></a>2.1登录接口</h4><pre><code class="hljs javascript"><span class="hljs-comment">//登录接口</span>app.post(<span class="hljs-string">'/login'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;    <span class="hljs-keyword">const</span> &#123; account, psw &#125; = req.body    <span class="hljs-comment">//根据用户名找用户</span>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> User.findOne(&#123; account &#125;).select(<span class="hljs-string">'+psw'</span>)    assert(user, <span class="hljs-number">422</span>, <span class="hljs-string">'用户不存在'</span>)    <span class="hljs-comment">//校验密码</span>    <span class="hljs-keyword">const</span> isValid = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bcrypt'</span>).compareSync(psw, user.psw)    assert(isValid, <span class="hljs-number">422</span>, <span class="hljs-string">'用户名或密码错误'</span>)    <span class="hljs-comment">//签名返回token</span>    <span class="hljs-keyword">const</span> token = jwt.sign(&#123;        _id: user._id,        id: user._id,        username: user.account    &#125;, app.get(<span class="hljs-string">'secret'</span>))    res.send(&#123; token &#125;)&#125;)</code></pre><p>登录时，通过解构赋值提取Post请求体中的账户和密码。登录验证的步骤如下：</p><ul><li>根据用户名在数据库中查找用户信息，使用assert判断是否查找成功，若查找失败，服务端返回422错误，附带用户不存在的信息。</li><li>成功查找到用户后，使用bcrypt模块生成密码的摘要，与数据库中的摘要进行对比，如果对比失败，则服务端返回422错误，附带账户或密码错误的信息。</li><li>密码验证通过后，使用JSONWebToken进行签名，密钥为定义在服务端的密钥，返回200状态码，并返回token</li></ul><h4 id="2-2-注册接口"><a href="#2-2-注册接口" class="headerlink" title="2.2 注册接口"></a>2.2 注册接口</h4><pre><code class="hljs javascript">router.post(<span class="hljs-string">'/'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;        assert(req.body.psw1 === req.body.psw2, <span class="hljs-number">422</span>, <span class="hljs-string">'两次密码不一致'</span>)        <span class="hljs-keyword">const</span> accountLocal = <span class="hljs-keyword">await</span> User.findOne(&#123; <span class="hljs-attr">account</span>: req.body.account &#125;)        assert(!accountLocal, <span class="hljs-number">502</span>, <span class="hljs-string">"用户已存在"</span>)        <span class="hljs-keyword">const</span> model = &#123;&#125;        model.account = req.body.account;        model.psw = req.body.psw1        <span class="hljs-keyword">await</span> req.Model.create(model)        res.send(model)    &#125;)</code></pre><p>注册时，除了前端限制，也要在后端进行相应的处理，以避免绕过前端的恶意注册，注册步骤如下：</p><ul><li>检验请求体的两次密码是否一致，不一致则返回422错误，附带两次密码不一致信息</li><li>若两次密码一致，则根据请求体的用户名在数据库进行查找，如果用户已经存在，则返回502错误，附带用户已存在的信息。</li><li>若无误，根据请求体的用户名和密码创建用户，存放到数据库中，其中密码经过bcrypt进行hash，而不是直接存放铭文。</li></ul><h4 id="2-3-用户数据模型"><a href="#2-3-用户数据模型" class="headerlink" title="2.3 用户数据模型"></a>2.3 用户数据模型</h4><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>)<span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> mongoose.Schema(&#123;    account: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> &#125;,    psw: &#123;        type: <span class="hljs-built_in">String</span>,        select: <span class="hljs-literal">false</span>,        <span class="hljs-keyword">set</span>(val) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">'bcrypt'</span>).hashSync(val, <span class="hljs-number">10</span>)        &#125;,    &#125;&#125;)<span class="hljs-built_in">module</span>.exports = mongoose.model(<span class="hljs-string">'User'</span>, schema)</code></pre><p>其中定义psw字段时使用set方法通过bcrypt对密码进行hash签名，生成摘要。用户在数据库中存储的方式为：</p><img src="http://images.nickname4th.vip/用户在数据库中的存储信息.png" srcset="/img/loading.gif" alt="用户在数据库中的存储信息" style="zoom:50%;" /><h4 id="2-4-全局错误处理"><a href="#2-4-全局错误处理" class="headerlink" title="2.4 全局错误处理"></a>2.4 全局错误处理</h4><pre><code class="hljs javascript">app.use(<span class="hljs-keyword">async</span> (err, req, res, next) =&gt; &#123;  res.status(err.statusCode || <span class="hljs-number">500</span>).send(&#123;    message: err.message  &#125;)&#125;)</code></pre><p>配合前端的http拦截器，返回错误信息。</p><h3 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3 中间件"></a>3 中间件</h3><h4 id="3-1-auth-js"><a href="#3-1-auth-js" class="headerlink" title="3.1 auth.js"></a>3.1 auth.js</h4><p>登录成功之后，对应用户访问自己资源的行为需要通过token来鉴定是否具有相应的权限。</p><pre><code class="hljs javascript"><span class="hljs-comment">//auth.js</span><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">options</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jsonwebtoken'</span>)    <span class="hljs-keyword">const</span> oUser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../models/User'</span>)    <span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http-assert'</span>)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) =&gt; &#123;        <span class="hljs-keyword">const</span> token = <span class="hljs-built_in">String</span>(req.headers.authorization || <span class="hljs-string">''</span>).split(<span class="hljs-string">' '</span>).pop()        assert(token, <span class="hljs-number">401</span>, <span class="hljs-string">'登录已过期'</span>)        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">const</span> &#123; id &#125; = jwt.verify(token, req.app.get(<span class="hljs-string">'secret'</span>))            <span class="hljs-comment">// console.log(id)</span>            assert(id, <span class="hljs-number">401</span>, <span class="hljs-string">'账户存在问题！'</span>)            req.user = <span class="hljs-keyword">await</span> oUser.findById(id)            assert(req.user._id, <span class="hljs-number">401</span>, <span class="hljs-string">"登录已过期"</span>)        &#125; <span class="hljs-keyword">catch</span> (error) &#123;            <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">401</span>).send(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">'登录已过期'</span> &#125;)        &#125;        <span class="hljs-comment">// console.log(req.user)</span>        <span class="hljs-keyword">await</span> next()    &#125;&#125;</code></pre><p>在具体使用时，如下面的获取用户页面的请求：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> auth = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../middle/auth'</span>)<span class="hljs-comment">//查看个人信息</span>router.get(<span class="hljs-string">'/'</span>, auth(), <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"user"</span>, req.user.account)  <span class="hljs-comment">// const model = await req.Model.findOne(&#123; account: req.user.account &#125;)</span>  res.send(req.user.account)&#125;)</code></pre><p>通过express的Router，在收到前端GET请求后，先通过CommJS的require语法执行上面auth.js中的代码，进行权限验证。</p><h4 id="3-2-resources-js"><a href="#3-2-resources-js" class="headerlink" title="3.2 resources.js"></a>3.2 resources.js</h4><p>在将来如果有更多的资源，我们可以将接口统一起来，根据前端的需求动态的请求后端的资源，这样更加灵活方便。</p><pre><code class="hljs javascript"><span class="hljs-comment">//resource.js</span><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">options</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) =&gt; &#123;        <span class="hljs-keyword">const</span> ModelName = <span class="hljs-built_in">require</span>(<span class="hljs-string">'inflection'</span>).classify(req.params.resource)        <span class="hljs-built_in">console</span>.log(req)        req.Model = <span class="hljs-built_in">require</span>(<span class="hljs-string">`../models/<span class="hljs-subst">$&#123;ModelName&#125;</span>`</span>)        next()    &#125;&#125;</code></pre><p>通过express的Router，将接口定义为</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> resource = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../middle/resource'</span>)app.use(<span class="hljs-string">'/api/:resource'</span>, resource(), router)</code></pre><p>这样在请求不同资源时，后端就会动态的访问对应的资源，如下面的请求</p><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> getInfo() &#123;  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.$http.get(<span class="hljs-string">"/api/users"</span>);  <span class="hljs-keyword">this</span>.account = res.data;&#125;,</code></pre><p>表示获取User的数据。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>express</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CommonJs和ES6模块导入导出</title>
    <link href="/2020/05/05/CommonJs%E5%92%8CES6%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <url>/2020/05/05/CommonJs%E5%92%8CES6%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>学习WebPack工具的一些前端基础，这是web前端系列的第一篇文章。</p><a id="more"></a><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><pre><code class="hljs javascript"><span class="hljs-comment">//导出</span><span class="hljs-comment">//test.js</span><span class="hljs-comment">//方式1</span><span class="hljs-built_in">module</span>.exports = &#123;  name:<span class="hljs-string">'module1'</span>,  add: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;    <span class="hljs-keyword">return</span> a + b  &#125;&#125;<span class="hljs-comment">//方式2</span>exports.name = <span class="hljs-string">'module1'</span>;exports.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;  <span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-comment">//导入</span><span class="hljs-comment">//index.js</span><span class="hljs-comment">//方式1</span><span class="hljs-keyword">const</span> test = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./test.js'</span>)<span class="hljs-keyword">const</span> add = test.add<span class="hljs-comment">//方式2，支持表达式动态导入</span><span class="hljs-keyword">const</span> modules = [<span class="hljs-string">'test.js'</span>,<span class="hljs-string">'test2.js'</span>]modules.forEach(<span class="hljs-function"><span class="hljs-params">name</span>=&gt;</span>&#123;  <span class="hljs-built_in">require</span>(<span class="hljs-string">'./'</span>+name)&#125;)</code></pre><p>CommonJS注意的地方</p><blockquote><ul><li>在实际使用中，为了提高可读性，建议将module.exports和exports语法语句放在模块最后</li><li>exports指向module.exports，因此不要直接给exports对象赋值，否则会导致module.exports导出失效</li><li>require语句在一个js文件中只<strong>执行一次</strong>，重复使用不会再执行导入模块中的语句</li><li>每个模块都有自己的作用域</li><li>CommonJs导入模块是对其值的拷贝，可以进行修改，不影响原模块</li></ul></blockquote><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><pre><code class="hljs javascript"><span class="hljs-comment">//导出</span><span class="hljs-comment">//test.js</span><span class="hljs-comment">//方式1，默认导出，只有一个export</span><span class="hljs-keyword">export</span> dufault &#123;  name:<span class="hljs-string">'test'</span>,  add:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;    <span class="hljs-keyword">return</span> a + b  &#125;&#125;<span class="hljs-comment">//方式2</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name = <span class="hljs-string">'test'</span><span class="hljs-keyword">export</span> add=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;  <span class="hljs-keyword">return</span> a+b&#125;<span class="hljs-comment">//方式3，默认导出</span><span class="hljs-keyword">const</span> name = <span class="hljs-string">'test'</span>add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;  <span class="hljs-keyword">return</span> a+b&#125;<span class="hljs-keyword">export</span> &#123;test,add&#125;<span class="hljs-comment">//方式3，命名导出</span><span class="hljs-keyword">const</span> name = <span class="hljs-string">'test'</span>add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;  <span class="hljs-keyword">return</span> a+b&#125;<span class="hljs-keyword">export</span> &#123;test <span class="hljs-keyword">as</span> test1,add <span class="hljs-keyword">as</span> add1&#125;<span class="hljs-comment">//导入</span><span class="hljs-comment">//index.js</span><span class="hljs-comment">//方式1，按照原名导入</span><span class="hljs-keyword">import</span> &#123;name,add&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./test.js'</span><span class="hljs-comment">//方式2，命名导入</span><span class="hljs-keyword">import</span> &#123;name <span class="hljs-keyword">as</span> name1, add <span class="hljs-keyword">as</span> add1&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./test.js'</span><span class="hljs-comment">//方式3 整体导入</span><span class="hljs-keyword">import</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./test.js'</span><span class="hljs-comment">//方式4，对默认导出的导入</span><span class="hljs-keyword">import</span> myModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./test.js'</span> <span class="hljs-comment">//相当于import default as myModule from './test.js'</span></code></pre><p>ES6注意的地方</p><blockquote><ul><li>每个模块有自身的作用域</li><li>所有导入的变量都是原模块的动态映射，是只读的，不可以对其进行修改</li><li>对于默认导出来说，导入可以接自定义变量名</li><li>导出、导出必须放在顶层作用域</li></ul></blockquote><h4 id="CommonJS和ES6的区别"><a href="#CommonJS和ES6的区别" class="headerlink" title="CommonJS和ES6的区别"></a>CommonJS和ES6的区别</h4><ul><li>CommonJS对模块依赖的解决是动态的，模块依赖关系的建立发生在代码<strong>运行</strong>阶段。ES6对模块依赖解决的办法是静态的，模块依赖关系的建立发生在代码<strong>编译</strong>阶段</li><li>CommonJS支持导入的路径是表达式，ES6的导入是声明式的，故不支持</li><li>ES6的好处<ul><li>死代码检测和排除</li><li>模块变量类型检查</li><li>编译器优化</li><li>可以利用ES6的特性解决循环依赖问题</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>CommonJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习</title>
    <link href="/2020/04/29/docker_learn/"/>
    <url>/2020/04/29/docker_learn/</url>
    
    <content type="html"><![CDATA[<p>Docker入门的一些基本语法，dockerfile相关的东西待补充。</p><a id="more"></a><h2 id="Docker-CE-on-Ubuntu-18-04"><a href="#Docker-CE-on-Ubuntu-18-04" class="headerlink" title="Docker CE on Ubuntu 18.04"></a>Docker CE on Ubuntu 18.04</h2><h3 id="安装步骤（来自官网）"><a href="#安装步骤（来自官网）" class="headerlink" title="安装步骤（来自官网）"></a>安装步骤（来自官网）</h3><ul><li>完全删除旧的Docker<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt-get remove docker docker-engine docker.io containerd runc</span></code></pre></li><li>升级apt包管理工具<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt-get update</span></code></pre></li><li>安装依赖使apt可以通过https获取包<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install \</span>    apt-transport-https \    ca-certificates \    curl \    gnupg-agent \    software-properties-common</code></pre></li><li>获取Docker的GPG密钥并验证<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><span class="hljs-meta">$</span><span class="bash"> sudo apt-key fingerprint 0EBFCD88</span></code></pre></li><li>安装Docker CE<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install docker-ce docker-ce-cli containerd.io</span></code></pre><h3 id="惯用配置"><a href="#惯用配置" class="headerlink" title="惯用配置"></a>惯用配置</h3></li><li>将Docker加入用户组<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo adduser <span class="hljs-variable">$USER</span> docker</span><span class="hljs-meta">#</span><span class="bash"> 避免每次使用docker命令时必须输入sudo，修改后重新登录shell即可</span></code></pre></li><li>更换国内镜像源<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim /etc/docker/daemon.json</span>&#123;  "registry-mirrors": ["https://vchck76f.mirror.aliyuncs.com"]&#125;<span class="hljs-meta">#</span><span class="bash"> 地址可以去阿里云免费申请</span></code></pre><h3 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h3></li></ul><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>docker run -it -v [imageID] [hostDir]:[dockerDir]</code></td><td>将宿主机的hostDir文件夹挂载到docker的dockerDir文件夹，如果不存在，将创建</td></tr><tr><td><code>docker run -it -v [imageID] [hostDir]:[dockerDir]:ro</code></td><td>ro即readOnly，使容器只能读取不能写入</td></tr></tbody></table><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>docker ps [-a] [-l]</code></td><td>查看运行中的容器，-a为查看历史所有的容器，-l为上一次运行的容器</td></tr><tr><td><code>docker images</code></td><td>查看docker镜像</td></tr><tr><td><code>docker run [-it] [--name] [imageID] [-d]</code></td><td>使用image创建容器，-i交互模式，-t为容器重新分配伪终端,–name为容器的昵称，-d为守护进程，即后台运行</td></tr><tr><td><code>docker start [name/containerID]</code></td><td>启动名为name或ID为containerID的容器</td></tr><tr><td><code>docker stop [name]</code></td><td>停止名为name或ID为containerID的容器</td></tr><tr><td><code>docker exec [-it] [name/containerID] [/bin/bash]</code></td><td>进入容器，可以指定伪终端的shell路径</td></tr><tr><td><code>docker search [name]</code></td><td>搜索名为name的镜像</td></tr><tr><td><code>docker pull [name]</code></td><td>拉取名为name的镜像到本地</td></tr><tr><td><code>docker rmi [imageID]</code></td><td>删除imageID镜像，删除前必须删除关联的容器</td></tr><tr><td><code>docker rm [name/containerID</code></td><td>删除名为name或ID为containerID的容器，删除前必须停止容器</td></tr><tr><td><code>docker commit [-a=&quot;&quot;] [-m=&quot;&quot;] [containerID] [NewImageName] [tag]</code></td><td>创建名为NewImageName的镜像，-a为作者信息，-m为说明</td></tr></tbody></table><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h3 id="容器持续化"><a href="#容器持续化" class="headerlink" title="容器持续化"></a>容器持续化</h3><h3 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h3><h3 id="Dockercompose"><a href="#Dockercompose" class="headerlink" title="Dockercompose"></a>Dockercompose</h3>]]></content>
    
    
    <categories>
      
      <category>容器技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派搭建NCS2环境并测试</title>
    <link href="/2020/03/05/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BANCS2%E7%8E%AF%E5%A2%83%E5%B9%B6%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/03/05/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BANCS2%E7%8E%AF%E5%A2%83%E5%B9%B6%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>做毕设和一些实验的基础，在树莓派环境搭建NCS2的依赖环境并进行相关测试</p><a id="more"></a><h3 id="OpenVINO-toolkit-for-RaspberryPi-树莓派NCS2环境搭建"><a href="#OpenVINO-toolkit-for-RaspberryPi-树莓派NCS2环境搭建" class="headerlink" title="OpenVINO toolkit for RaspberryPi(树莓派NCS2环境搭建)"></a>OpenVINO toolkit for RaspberryPi(树莓派NCS2环境搭建)</h3><p>@Nickname4th 2019/10/01</p><p>Call me at: 1733****598</p><h3 id="烧写官方镜像"><a href="#烧写官方镜像" class="headerlink" title="烧写官方镜像"></a>烧写官方镜像</h3><ul><li>使用BleanEtchar，略</li></ul><h3 id="TensorFlow配置"><a href="#TensorFlow配置" class="headerlink" title="TensorFlow配置"></a>TensorFlow配置</h3><h4 id="更换apt和pip源"><a href="#更换apt和pip源" class="headerlink" title="更换apt和pip源"></a>更换apt和pip源</h4><pre><code class="hljs shell">sudo vim /etc/apt/sources.list</code></pre><blockquote><p>注释原来的源，添加 </p><p>deb <a href="http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a> stretch main contrib non-free rpi<br>deb-src <a href="http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a> stretch main contrib non-free rpi</p></blockquote><pre><code class="hljs shell">pip install pippip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</code></pre><h4 id="安装matplot-使用VNC调试更直观，后续可注释相关代码并以CLI启动"><a href="#安装matplot-使用VNC调试更直观，后续可注释相关代码并以CLI启动" class="headerlink" title="安装matplot(使用VNC调试更直观，后续可注释相关代码并以CLI启动)"></a>安装matplot(使用VNC调试更直观，后续可注释相关代码并以CLI启动)</h4><pre><code class="hljs shell">sudo pip3 install matplotlib</code></pre><h4 id="安装TensorFlow"><a href="#安装TensorFlow" class="headerlink" title="安装TensorFlow"></a>安装TensorFlow</h4><pre><code class="hljs shell">sudo pip3 install tensorflow</code></pre><blockquote><p>安装依赖包时出现报错时将报错的依赖包单独使用sudo pip3 install [包名]即可</p></blockquote><ul><li>安装第三方whl</li></ul><blockquote><p>集成了TensorFlow的api，可以快速测试一个模型</p><pre><code class="hljs shell">sudo pip3 install obapi-1.0.0-py3-none-any.whl</code></pre><p>感谢作者@obapi</p></blockquote><ul><li><p>根据代码移入模型相关文件夹和TensorFlow相关文件夹并修改路径</p><blockquote><p>这里主要是object_detection和silm文件夹等</p></blockquote></li></ul><h4 id="安装opencv及其依赖"><a href="#安装opencv及其依赖" class="headerlink" title="安装opencv及其依赖"></a>安装opencv及其依赖</h4><pre><code class="hljs shell">sudo pip3 install opencv-pythonsudo apt-get install libcblas-devsudo apt-get install libhdf5-devsudo apt-get install libhdf5-serial-devsudo apt-get install libatlas-base-devsudo apt-get install libjasper-dev sudo apt-get install libqtgui4 sudo apt-get install libqt4-test</code></pre><blockquote><p>由于树莓派官方系统更新，可能会因为依赖冲突发生多次错误，耐心按照apt的报错决定是否覆盖安装相关依赖包</p></blockquote><h3 id="TensorFlow模型转换及前后性能测试"><a href="#TensorFlow模型转换及前后性能测试" class="headerlink" title="TensorFlow模型转换及前后性能测试"></a>TensorFlow模型转换及前后性能测试</h3><ul><li><p><a href="https://software.intel.com/en-us/openvino-toolkit/choose-download/free-download-macos" target="_blank" rel="noopener">下载最新版本的macOS*的工具箱OpenVINO toolkit</a>，记住激活码</p></li><li><p>按照<a href="https://docs.openvinotoolkit.org/latest/_docs_install_guides_installing_openvino_macos.html" target="_blank" rel="noopener">官网说明</a>进行配置</p></li><li><p>本次使用冻结模型ssdlite_mobilenet_v2_coco_2018_05_09(官网发现他正好是受支持的拓扑结构)</p></li><li><p>下载模型，将其转换成IR中间件表示</p><ul><li><a href="http://download.tensorflow.org/models/object_detection/ssdlite_mobilenet_v2_coco_2018_05_09.tar.gz" target="_blank" rel="noopener">下载传送门</a></li><li>开始模型转换，<a href="https://docs.openvinotoolkit.org/latest/_docs_MO_DG_prepare_model_convert_model_Convert_Model_From_TensorFlow.html" target="_blank" rel="noopener">转换指南</a></li><li>得到.xml和.bin文件</li><li>修改程序进行对比</li></ul></li></ul><h4 id="TestWithOutNCS2-py"><a href="#TestWithOutNCS2-py" class="headerlink" title="TestWithOutNCS2.py"></a>TestWithOutNCS2.py</h4><blockquote><p>这里就是之前在导盲杖和MacBook Pro上跑的目标检测算法</p></blockquote><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-keyword">from</span> obapi <span class="hljs-keyword">import</span> label_map_util<span class="hljs-keyword">from</span> obapi <span class="hljs-keyword">import</span> visualization_utils <span class="hljs-keyword">as</span> vis_util<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<span class="hljs-comment"># import matplotlib.pyplot as plt</span><span class="hljs-keyword">import</span> timesys.path.append(<span class="hljs-string">'/home/pi/NCS2/object_detection'</span>) <span class="hljs-comment"># point to your tensorflow dir</span>sys.path.append(<span class="hljs-string">'/home/pi/NCS2/slim'</span>) <span class="hljs-comment"># point ot your slim dir</span><span class="hljs-comment"># What model to download.</span>MODEL_NAME = <span class="hljs-string">'/home/pi/NCS2/object_detection/'</span>PATH_TO_CKPT = MODEL_NAME + <span class="hljs-string">'/frozen_inference_graph.pb'</span>PATH_TO_LABELS = <span class="hljs-string">'/home/pi/NCS2/obj/data/mscoco_label_map.pbtxt'</span>NUM_CLASSES = <span class="hljs-number">90</span>detection_graph = tf.Graph()<span class="hljs-keyword">with</span> detection_graph.as_default():  od_graph_def = tf.GraphDef()  <span class="hljs-keyword">with</span> tf.gfile.GFile(PATH_TO_CKPT, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> fid:    serialized_graph = fid.read()    od_graph_def.ParseFromString(serialized_graph)    tf.import_graph_def(od_graph_def, name=<span class="hljs-string">''</span>)<span class="hljs-comment">#Loading label map</span>label_map = label_map_util.load_labelmap(PATH_TO_LABELS)categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=<span class="hljs-literal">True</span>)category_index = label_map_util.create_category_index(categories)<span class="hljs-comment">#Helper code</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_image_into_numpy_array</span><span class="hljs-params">(image)</span>:</span>  (im_width, im_height) = image.size  <span class="hljs-keyword">return</span> np.array(image.getdata()).reshape(      (im_height, im_width, <span class="hljs-number">3</span>)).astype(np.uint8)TEST_IMAGE_PATHS = [<span class="hljs-string">'/home/pi/NCS2/obj/test_images/1.jpg'</span>]<span class="hljs-comment"># Size, in inches, of the output images.</span>IMAGE_SIZE = (<span class="hljs-number">16</span>, <span class="hljs-number">9</span>)<span class="hljs-keyword">with</span> detection_graph.as_default():  <span class="hljs-keyword">with</span> tf.Session(graph=detection_graph) <span class="hljs-keyword">as</span> sess:    image_tensor = detection_graph.get_tensor_by_name(<span class="hljs-string">'image_tensor:0'</span>)    detection_boxes = detection_graph.get_tensor_by_name(<span class="hljs-string">'detection_boxes:0'</span>)    detection_scores = detection_graph.get_tensor_by_name(<span class="hljs-string">'detection_scores:0'</span>)    detection_classes = detection_graph.get_tensor_by_name(<span class="hljs-string">'detection_classes:0'</span>)    num_detections = detection_graph.get_tensor_by_name(<span class="hljs-string">'num_detections:0'</span>)    <span class="hljs-keyword">import</span> cv2    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:        <span class="hljs-keyword">for</span> image_path <span class="hljs-keyword">in</span> TEST_IMAGE_PATHS:            start = time.clock()            cap = cv2.VideoCapture(<span class="hljs-number">0</span>)            ret, frame = cap.read()            cv2.imwrite(<span class="hljs-string">"/home/pi/NCS2/obj/test_images/1.jpg"</span>, frame)            cap.release()            image = Image.open(image_path)            image_np = load_image_into_numpy_array(image)            image_np_expanded = np.expand_dims(image_np, axis=<span class="hljs-number">0</span>)            image_tensor = detection_graph.get_tensor_by_name(<span class="hljs-string">'image_tensor:0'</span>)            boxes = detection_graph.get_tensor_by_name(<span class="hljs-string">'detection_boxes:0'</span>)            scores = detection_graph.get_tensor_by_name(<span class="hljs-string">'detection_scores:0'</span>)            classes = detection_graph.get_tensor_by_name(<span class="hljs-string">'detection_classes:0'</span>)            num_detections = detection_graph.get_tensor_by_name(<span class="hljs-string">'num_detections:0'</span>)            <span class="hljs-comment"># Actual detection.</span>            (boxes, scores, classes, num_detections) = sess.run(                [boxes, scores, classes, num_detections],                feed_dict=&#123;image_tensor: image_np_expanded&#125;)            <span class="hljs-comment"># Visualization of the results of a detection.</span>            vis_util.visualize_boxes_and_labels_on_image_array(                image_np,                np.squeeze(boxes),                np.squeeze(classes).astype(np.int32),                np.squeeze(scores),                category_index,                use_normalized_coordinates=<span class="hljs-literal">True</span>,                line_thickness=<span class="hljs-number">8</span>)            a = np.squeeze(classes).astype(np.int32)[<span class="hljs-number">0</span>]            elapsed = (time.clock() - start)            name = category_index[a][<span class="hljs-string">'name'</span>]            print(<span class="hljs-string">"This is a "</span>,name)            print(<span class="hljs-string">"Time used:"</span>,elapsed)            <span class="hljs-comment"># plt.figure(figsize=IMAGE_SIZE)</span>            <span class="hljs-comment"># plt.imshow(image_np)</span>            <span class="hljs-comment"># plt.show()</span></code></pre><ul><li>冷启动时间：20.6s</li><li>单独进行一次图像识别时间：6.03s</li></ul><h4 id="TestWithNCS2-py"><a href="#TestWithNCS2-py" class="headerlink" title="TestWithNCS2.py"></a>TestWithNCS2.py</h4><blockquote><p>这里是将原来的目标检测算法转换后，通过计算棒执行的目标检测</p></blockquote><pre><code class="hljs shell">cd object_detection-masterpython3 main.py -d MYRIAD -i "cam" -m "ssd_v2.xml" # 使用摄像头进行实时目标检测 python3 main.py  -d MYRIAD -i "Cars - 1900.mp4" -m "./mobilenet-ssd/FP32/mobilenet-ssd.xml" # 在测试视频中运行目标检测</code></pre><blockquote><p>注意：通过ssh进行目标检测时，会由于无法调用display而报错，这里将cv2.imshow()注释即可，如果要观测，可以通过VNC连接至树莓派，通过内置终端执行语句</p><p>object_detection-master文件夹资源链接：<a href="https://yaleedupl-my.sharepoint.com/:f:/g/personal/acs_shier_love/Eu6GMrDyxi9DkFD4rAKy6-ABjpyvwmHuBWWkQRijtCo4rQ?e=zr7eIA" target="_blank" rel="noopener">https://yaleedupl-my.sharepoint.com/:f:/g/personal/acs_shier_love/Eu6GMrDyxi9DkFD4rAKy6-ABjpyvwmHuBWWkQRijtCo4rQ?e=zr7eIA</a></p></blockquote><pre><code class="hljs python"><span class="hljs-comment">#main.py代码</span><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> os<span class="hljs-keyword">from</span> argparse <span class="hljs-keyword">import</span> ArgumentParser<span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> logging <span class="hljs-keyword">as</span> log<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> io<span class="hljs-keyword">import</span> detect <span class="hljs-keyword">as</span> dt<span class="hljs-keyword">from</span> openvino.inference_engine <span class="hljs-keyword">import</span> IENetwork, IEPlugin<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Pathsys.path.insert(<span class="hljs-number">0</span>, str(Path().resolve().parent.parent))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_argparser</span><span class="hljs-params">()</span>:</span>    parser = ArgumentParser()    parser.add_argument(<span class="hljs-string">"-m"</span>, <span class="hljs-string">"--model"</span>, help=<span class="hljs-string">"Path to an .xml file with a trained model."</span>, required=<span class="hljs-literal">True</span>, type=str)    parser.add_argument(<span class="hljs-string">"-i"</span>, <span class="hljs-string">"--input"</span>,                        help=<span class="hljs-string">"Path to video file or image. 'cam' for capturing video stream from camera"</span>,                        type=str)    parser.add_argument(<span class="hljs-string">"-l"</span>, <span class="hljs-string">"--cpu_extension"</span>,                        help=<span class="hljs-string">"MKLDNN (CPU)-targeted custom layers.Absolute path to a shared library with the kernels "</span>                             <span class="hljs-string">"impl."</span>, type=str, default=<span class="hljs-literal">None</span>)    parser.add_argument(<span class="hljs-string">"-pp"</span>, <span class="hljs-string">"--plugin_dir"</span>, help=<span class="hljs-string">"Path to a plugin folder"</span>, type=str, default=<span class="hljs-literal">None</span>)    parser.add_argument(<span class="hljs-string">"-d"</span>, <span class="hljs-string">"--device"</span>,                        help=<span class="hljs-string">"Specify the target device to infer on; CPU, GPU, FPGA, MYRIAD or HDDL is acceptable. Sample "</span>                             <span class="hljs-string">"will look for a suitable plugin for device specified (CPU by default)"</span>, default=<span class="hljs-string">"CPU"</span>,                        type=str)    parser.add_argument(<span class="hljs-string">"--labels"</span>, help=<span class="hljs-string">"Labels mapping file"</span>, default=<span class="hljs-literal">None</span>, type=str)    parser.add_argument(<span class="hljs-string">"-pt"</span>, <span class="hljs-string">"--prob_threshold"</span>, help=<span class="hljs-string">"Probability threshold for detections filtering"</span>,                        default=<span class="hljs-number">0.5</span>, type=float)    parser.add_argument(<span class="hljs-string">"-o"</span>, <span class="hljs-string">"--output_dir"</span>, help=<span class="hljs-string">"If set, it will write a video here instead of displaying it"</span>,                        default=<span class="hljs-literal">None</span>, type=str)    <span class="hljs-keyword">return</span> parser<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_sure_path_exists</span><span class="hljs-params">(path)</span>:</span>    <span class="hljs-keyword">try</span>:        os.makedirs(path)    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> exception:        <span class="hljs-keyword">pass</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    is_async_mode = <span class="hljs-literal">True</span>    args = build_argparser().parse_args()    object_detection=dt.Detectors(args.device,args.model,args.cpu_extension,args.plugin_dir,is_async_mode)    resultant_initialisation_object=object_detection.initialise_inference()    input_stream = args.input    cap = cv2.VideoCapture(<span class="hljs-number">0</span>)    ret, frame = cap.read()    cv2.imwrite(<span class="hljs-string">"/home/pi/NCS2/obj/test_images/1.jpg"</span>, frame)    video_len = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))    frame_width = int(cap.get(<span class="hljs-number">3</span>))    frame_height = int(cap.get(<span class="hljs-number">4</span>))    cur_request_id = <span class="hljs-number">0</span>    next_request_id = <span class="hljs-number">1</span>    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">while</span> cap.isOpened():            start = time.clock()            ret, frame = cap.read()            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret:                <span class="hljs-keyword">break</span>            initial_w = cap.get(<span class="hljs-number">3</span>)            initial_h = cap.get(<span class="hljs-number">4</span>)            res_inference=resultant_initialisation_object.process_frame(cur_request_id,next_request_id,frame,initial_h,initial_w,<span class="hljs-literal">False</span>)            resultant_frame=resultant_initialisation_object.placeBoxes(res_inference,<span class="hljs-literal">None</span>,<span class="hljs-number">0.5</span>,frame,initial_w,initial_h,<span class="hljs-literal">False</span>,cur_request_id)            key = cv2.waitKey(<span class="hljs-number">1</span>)            <span class="hljs-keyword">if</span> key == <span class="hljs-number">27</span>:                <span class="hljs-keyword">break</span>            elapsed = (time.clock() - start)            print(<span class="hljs-string">"Time used:"</span>,elapsed)        cap.release()    <span class="hljs-keyword">finally</span>:        <span class="hljs-keyword">del</span> resultant_initialisation_object.exec_net<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    sys.exit(main() <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)</code></pre><ul><li>冷启动时间：2.0s</li><li>单独进行一次图像识别时间：0.06s</li></ul><h3 id="RealTime的性能对比"><a href="#RealTime的性能对比" class="headerlink" title="RealTime的性能对比"></a>RealTime的性能对比</h3><blockquote><p>相同场景下实时识别，对比帧数</p></blockquote><p>待续。。。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NCS2</tag>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨年旅行计划</title>
    <link href="/2019/12/06/%E8%B7%A8%E5%B9%B4%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2019/12/06/%E8%B7%A8%E5%B9%B4%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>2019-2020跨年旅行计划，实际过程略有差别。</p><a id="more"></a><h2 id="旅行规划"><a href="#旅行规划" class="headerlink" title="旅行规划"></a>旅行规划</h2><blockquote><p>@Nickname4th @是这个zhang馨</p></blockquote><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li>📅2019年12月27日-2020年1月1日<ul><li>2019年12月28日凌晨01:30分小仙女🧚‍♀️抵达美兰机场✈️</li><li>2020年1月1日晚上23:30分一起回家</li></ul></li></ul><h4 id="物资筹备"><a href="#物资筹备" class="headerlink" title="物资筹备"></a>物资筹备</h4><ul><li>穿<ul><li>可爱的小裙裙裙👗</li><li>可爱或酷的鞋👢</li><li>御寒的外套🧥</li><li>游泳的👙</li><li>私人物品</li></ul></li><li>旅行用品<ul><li>Canon M6📷</li><li>iPhone 11 📱</li><li>学生证👩‍🎓👨‍🎓</li><li>非常规必备化妆系列<ul><li>防晒霜🧴</li><li>补水💦</li></ul></li><li>Money💰</li></ul></li><li>为了回家<ul><li>羽绒服</li><li>围巾🧣</li><li>等防寒物品</li></ul></li></ul><h4 id="路线和时间"><a href="#路线和时间" class="headerlink" title="路线和时间"></a>路线和时间</h4><table><thead><tr><th align="center">时间</th><th align="center">地点</th><th align="center">项目</th></tr></thead><tbody><tr><td align="center">12.28</td><td align="center">观澜湖冯小刚电影公社、蜡像馆</td><td align="center"></td></tr><tr><td align="center">12.29</td><td align="center">南山寺、天涯海角、鹿回头</td><td align="center"></td></tr><tr><td align="center">12.30</td><td align="center">蜈支洲岛、椰梦长廊</td><td align="center"></td></tr><tr><td align="center">12.31</td><td align="center">亚龙湾天堂森林公园、玻璃栈道、玫瑰谷森林公园</td><td align="center"></td></tr></tbody></table><ul><li>12.28 海口 观澜湖华谊冯小刚电影公社🎬     观澜湖矿物质温泉主题公园⛲️<ul><li>海口东站——观澜湖<ul><li>1942民国街</li><li>南洋街</li><li>芳华小院</li><li>海洋馆🐬</li><li>名人蜡像馆</li><li>温泉♨️</li></ul></li><li>傍晚：海口东站——三亚🚄</li><li>住：三亚湾（待定）</li></ul></li><li>12.29 三亚 三亚湾<ul><li>南山寺<ul><li>南海观音</li></ul></li><li>鹿回头🦌</li><li>天涯海角</li></ul></li><li>12.30 三亚 亚龙湾<ul><li>亚龙湾热带天堂森林公园<ul><li>玻璃栈道</li><li>环游</li></ul></li><li>玫瑰谷森林公园</li><li>三亚千古情</li></ul></li><li>12.31 三亚 蜈支洲岛 <ul><li>槟榔谷</li><li>五指山漂流</li><li>凤凰岛酒店天空酒廊（待定）</li></ul></li><li>1.1海口 小刘的大学生活体验🏫<ul><li>海口东站——海南大学<ul><li>南门第一家清补凉🥗</li><li>校车🚌参观小刘平时呆的地方</li></ul></li><li>美兰机场✈️——成都双流</li></ul></li></ul><h4 id="Something"><a href="#Something" class="headerlink" title="Something"></a>Something</h4><ul><li><input disabled="" type="checkbox"> 在某个海边或高处🏖看日落</li><li><input checked="" disabled="" type="checkbox"> 一起吹吹风</li><li><input disabled="" type="checkbox"> 拍一张落日时分的剪影</li><li><input checked="" disabled="" type="checkbox"> 在某个海鲜市场寻找小张心心念的螃蟹🦀</li><li><input disabled="" type="checkbox"> 带上漂流瓶许一个愿望</li></ul><h4 id="预算和经费"><a href="#预算和经费" class="headerlink" title="预算和经费"></a>预算和经费</h4><ul><li><p>机票🛫</p><ul><li>小张来回 ￥2240</li><li>小刘回     ￥800</li></ul></li><li><p>车马费🐴</p></li></ul><ul><li><p>吃喝玩乐🍲</p></li><li><p>住宿🏡</p></li><li><p>纪念品🎁</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>个人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
      <tag>纪念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
