<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript原型链</title>
    <link href="/2020/05/15/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2020/05/15/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>简单梳理一下JavaScript原型链。</p><a id="more"></a><h2 id="JavaScript原型链"><a href="#JavaScript原型链" class="headerlink" title="JavaScript原型链"></a>JavaScript原型链</h2><h3 id="1-JavaScript创建对象的方式"><a href="#1-JavaScript创建对象的方式" class="headerlink" title="1 JavaScript创建对象的方式"></a>1 JavaScript创建对象的方式</h3><ul><li><p>字面量</p><pre><code class="javascript">let obj1 = {name:&#39;liutao&#39;};let obj2 = new Object({name:&#39;liutao&#39;});</code></pre></li><li><p>构造函数</p><pre><code class="javascript">let M = function(name){  this.name = name;}let obj3 = new M(&#39;liutao&#39;)</code></pre></li><li><p>create方法</p><pre><code class="javascript">let obj = {name:&#39;liutao&#39;}let obj4 = Object.create(obj)</code></pre></li></ul><h3 id="2-相关的关键字"><a href="#2-相关的关键字" class="headerlink" title="2 相关的关键字"></a>2 相关的关键字</h3><ul><li>实例对象</li><li>原型对象</li><li>构造函数</li><li>Function构造函数</li><li>Object构造函数</li><li>Function原型</li><li>Object原型</li></ul><h3 id="3-联系"><a href="#3-联系" class="headerlink" title="3 联系"></a>3 联系</h3><h4 id="3-1-设定（约定俗成）"><a href="#3-1-设定（约定俗成）" class="headerlink" title="3.1 设定（约定俗成）"></a>3.1 设定（约定俗成）</h4><ul><li>每一个实例对象（除了null）都存在__proto__属性</li><li>每一个函数都有一个prototype属性，指向其构造的对象的原型</li><li>每一个原型都有一个constructor，指向其关联的构造函数</li></ul><h4 id="3-2-基本原则"><a href="#3-2-基本原则" class="headerlink" title="3.2 基本原则"></a>3.2 基本原则</h4><ul><li><p>==实例对象==的==__proto__==属性指向==其原型对象==，实例对象的==构造函数==的==prototype==也指向==该==实例对象的==原型对象==</p></li><li><p>原型对象也有原型，原型链的==起点==为具体的==实例对象==，终点为==Object==，Object的原型为null，即没有原型对象</p></li><li><p>一个对象的==原型对象==的==constructor==属性指向==该==对象的==构造函数==</p></li><li><p>利用原型链可以进行多重继承</p></li></ul><h4 id="3-2-实例的-proto-属性和prototype属性"><a href="#3-2-实例的-proto-属性和prototype属性" class="headerlink" title="3.2 实例的__proto__属性和prototype属性"></a>3.2 实例的__proto__属性和prototype属性</h4><pre><code class="javascript">let obj1 = {name:&#39;liutao&#39;};    //字面量创建一个实例对象let M = function(name){     //M是构造函数  this.name = name;}let obj2 = new M(&#39;liutao&#39;);    //构造函数创建一个实例对象console.log(obj1.__proto__);//{}，即obj1的原型对象console.log(obj2.__proto__);//M{}，即obj2的原型对象console.log(obj2.__proto__===M.prototype)//通过3.1可知M.prototype指向其构造的对象即obj2的原型//这里可以得出，字面量实例对象的__proto__属性和构造函数实例对象的__proto__属性指向各自的原型对象</code></pre><h4 id="3-3-原型对象的-proto-属性和prototype属性"><a href="#3-3-原型对象的-proto-属性和prototype属性" class="headerlink" title="3.3 原型对象的__proto__属性和prototype属性"></a>3.3 原型对象的__proto__属性和prototype属性</h4><pre><code class="javascript">console.log(obj1.__proto__.__proto__);//null，由于obj1是由Object构造函数创建的，所以obj1.__proto__指向Object的prototype，而obj1.__proto__.__proto__指向Object的原型，即nullconsole.log(obj2.__proto__.__proto__);//{}，由于obj2是由M构造函数创建的，所以obj2.__proto__指向M.prototype，而M是由Object构造函数创建的，所以obj2.__proto__.__proto__指向M.prototype.__proto__，即Object.__proto__，即obj1.__proto__//验证console.log(obj2.__proto__.__proto__ === obj1.__proto__);//trueconsole.log(obj2.__proto__.__proto__.__proto__);//false</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>原型链的图其实画的不太好，但是只要理解了3.1和3.2的内容，就很容易理解原型链了。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Vue和MQTT的简单IOT系统</title>
    <link href="/2020/05/13/%E5%9F%BA%E4%BA%8EVue%E5%92%8CMQTT%E7%9A%84%E7%AE%80%E5%8D%95IOT%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/05/13/%E5%9F%BA%E4%BA%8EVue%E5%92%8CMQTT%E7%9A%84%E7%AE%80%E5%8D%95IOT%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>最近有个同学有点需求，简单帮忙实现了一下，前端部分使用了Vue+ElementUI，后端部分使用了MongoDB，中间使用MQTT协议的“发布——订阅”模式实现消息的传递。之前使用Docker在腾讯云搭建了一个环境，传送门<a href="https://github.com/LiuTianjie/zc_web" target="_blank" rel="noopener">A lot project build with Vue and Docker</a>，如果你没有docker的相关知识，可以直接查看代码的web和server文件夹即可。</p><a id="more"></a><h2 id="基于Vue和MQTT的简单IOT系统"><a href="#基于Vue和MQTT的简单IOT系统" class="headerlink" title="基于Vue和MQTT的简单IOT系统"></a>基于Vue和MQTT的简单IOT系统</h2><img src="http://images.nickname4th.vip/zc_bb.png" srcset="/img/loading.gif" alt="zc_bb" style="zoom: 25%;" /><p>整个系统可以分为前端、后端和硬件三个部分，前端通过模拟购票和开锁与后端数据库交互，并通过MQTT协议与树莓派通信，树莓派控制GPIO引脚信号控制IOT设备。</p><h3 id="1-前端部分"><a href="#1-前端部分" class="headerlink" title="1 前端部分"></a>1 前端部分</h3><h4 id="1-1-全局http处理"><a href="#1-1-全局http处理" class="headerlink" title="1.1 全局http处理"></a>1.1 全局http处理</h4><pre><code class="javascript">import axios from &#39;axios&#39;import Vue from &#39;vue&#39;const http = axios.create({    baseURL: &#39;url&#39;})http.interceptors.response.use(res =&gt; {    return res}, err =&gt; {    //服务端返回错误通用处理方案，并使用element的message进行提示    if (err.response.data) {        Vue.prototype.$message.error({            type: &#39;error&#39;,            message: err.response.data        });        console.log(err.response.status)    }    return Promise.reject(err)})export default http</code></pre><p>使用axios进行网络请求，添加http拦截器，将服务端返回的错误码和信息返回。</p><h4 id="1-2-模拟购票"><a href="#1-2-模拟购票" class="headerlink" title="1.2 模拟购票"></a>1.2 模拟购票</h4><p>简单的表单验证，利用vue的ref引用一个p标签来展示购票结果。</p><pre><code class="vue">&lt;div class=&quot;buy&quot; v-loading.fullscreen.lock=&quot;loading&quot;&gt;  &lt;el-card header=&quot;购买车票（模拟）&quot; class=&quot;check-card&quot;&gt;    &lt;div class=&quot;info&quot;&gt;      &lt;p ref=&quot;answer&quot;&gt;&lt;/p&gt;    &lt;/div&gt;  &lt;/el-card&gt;&lt;/div&gt;&lt;script&gt;methods: {    check() {      let that = this;      this.$refs[&quot;formData&quot;].validate(async valid =&gt; {        if (valid) {          this.$refs.answer.innerHTML = &quot;购票中，请稍后&quot;;          this.loading = true;          try {            const res = await this.$http.post(&quot;/orders&quot;, this.formData);            setTimeout(() =&gt; {              this.loading = false;              this.$message({                message: &quot;购票成功！&quot;,                type: &quot;success&quot;              });            }, 500);            this.resetForm(&quot;formData&quot;);            this.$refs.answer.innerHTML = `购票成功！&lt;/p&gt;&lt;p&gt;          日期：${res.data.date}&lt;/p&gt;&lt;p&gt;          车次：${res.data.train}&lt;/p&gt;&lt;p&gt;          座位：${res.data.set}`;          } catch (err) {            setTimeout(() =&gt; {              this.loading = false;              this.$refs.answer.innerHTML = &quot;购票失败！&quot;;            }, 500);          }        } else {          this.$message.error(&quot;输入有误，请重试！&quot;);        }      });    },}&lt;/script&gt;</code></pre><ul><li>使用了v-loading做等待时的缓冲动画</li><li>利用ref控制购票状态</li></ul><h4 id="1-2-模拟验证"><a href="#1-2-模拟验证" class="headerlink" title="1.2 模拟验证"></a>1.2 模拟验证</h4><pre><code class="vue">&lt;el-form :model=&quot;formData&quot; ref=&quot;formData&quot; label-width=&quot;100px&quot; @submit.native.prevent=&quot;check&quot;&gt;  &lt;el-form-item    label=&quot;身份证号&quot;    prop=&quot;id&quot;    :rules=&quot;[              { required: true, message: &#39;身份证号码不能为空&#39;},              { required: true, message: &#39;请填写证件号码&#39;, trigger: &#39;blur&#39; },              { pattern: /(^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$)|(^[1-9]\d{5}\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{2}$)/,                message: &#39;证件号码格式有误！&#39;,                trigger: &#39;blur&#39;              }]&quot;&gt;    &lt;el-input      class=&quot;check-box&quot;      type=&quot;id&quot;      v-model=&quot;formData.id&quot;      autocomplete=&quot;off&quot;      placeholder=&quot;请输入身份证号码&quot;&gt;    &lt;/el-input&gt;  &lt;/el-form-item&gt;     &lt;el-button type=&quot;primary&quot; native-type=&quot;submit&quot;&gt;提交&lt;/el-button&gt;     &lt;el-button @click=&quot;resetForm(&#39;formData&#39;)&quot;&gt;重置&lt;/el-button&gt;   &lt;/el-form-item&gt;&lt;/el-form&gt;</code></pre><ul><li>使用element表单验证，rules中使用正则表达式限制身份证号码的格式</li><li>@submit.native.prevent=”check”，阻止表单的自动提交</li><li>提交按钮绑定native-type=”submit”，点击提交</li></ul><h3 id="2-后端部分"><a href="#2-后端部分" class="headerlink" title="2 后端部分"></a>2 后端部分</h3><h4 id="2-1-MQTT-Server"><a href="#2-1-MQTT-Server" class="headerlink" title="2.1 MQTT Server"></a>2.1 MQTT Server</h4><pre><code class="javascript">var mosca = require(&#39;mosca&#39;);//构建自带服务器var MqttServer = new mosca.Server({    port: 1883});//对服务器端口进行配置， 在此端口进行监听MqttServer.on(&#39;clientConnected&#39;, function (client) {    //监听连接    console.log(&#39;client connected&#39;, client.id);});/** * 监听MQTT主题消息 **/MqttServer.on(&#39;published&#39;, function (packet, client) {    //当客户端有连接发布主题消息    var topic = packet.topic;    console.log(packet);    switch (topic) {        case &#39;train1&#39;:            console.log(&#39;message-publish&#39;, packet.payload.toString());            //MQTT转发主题消息            //MqttServer.publish({ topic: &#39;other&#39;, payload: &#39;sssss&#39; });            break;        case &#39;train2&#39;:            console.log(&#39;message-123&#39;, packet.payload.toString());            break;    }});MqttServer.on(&#39;ready&#39;, function () {    //当服务开启时    console.log(&#39;mqtt is running...&#39;);});</code></pre><ul><li>通过mosca新建mqtt服务器，监听1883端口</li><li>利用switch函数，监听从客户的publish的消息</li></ul><h4 id="2-2-Express服务器接口"><a href="#2-2-Express服务器接口" class="headerlink" title="2.2 Express服务器接口"></a>2.2 Express服务器接口</h4><pre><code class="javascript">const Model = require(&#39;../../models/Order&#39;)const mqtt = require(&#39;mqtt&#39;);const client = mqtt.connect(&#39;mqtt://host&#39;); //连接到服务端//验证并删除订单记录router.get(&#39;/orders/:id&#39;, async (req, res) =&gt; {  const item = await Model.findOne({ user: req.params.id })  if (item === null) {    res.status(401).send(&quot;未查到数据！&quot;)  }  else {    const id = item._id    console.log(item)    const msg = await Model.findOneAndDelete({ _id: id })    console.log(&quot;使用成功！已删除！&quot;)    res.send(item)    client.publish(&#39;train1&#39;, msg.set+&#39;&#39;, { qos: 0, retain: true });  }})</code></pre><ul><li>使用express的router定义后端路由，通过url传递参数匹配特定用户的id，进行CURD操作</li><li>创建mqtt客户端，删除时向“train1”频道发布信息</li></ul><h3 id="3-硬件部分"><a href="#3-硬件部分" class="headerlink" title="3 硬件部分"></a>3 硬件部分</h3><h4 id="3-1-示意图和电路图"><a href="#3-1-示意图和电路图" class="headerlink" title="3.1 示意图和电路图"></a>3.1 示意图和电路图</h4><ul><li>示意图</li></ul><img src="http://images.nickname4th.vip/zc_bb.png" srcset="/img/loading.gif" alt="zc_bb" style="zoom: 25%;" /><ul><li>电路图</li></ul><img src="http://images.nickname4th.vip/zc_图示.png" srcset="/img/loading.gif" alt="zc_图示" style="zoom:25%;" /><ul><li><p>GPIO 11 连接至L298N驱动板的ENA，用于发送高低电平信号，GPIO 35、36连接L298N的IN1、IN2，用于控制OUT1的输出，L298N真值表如下：</p><table><thead><tr><th align="center">ENA</th><th align="center">IN1</th><th align="center">IN2</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">x</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">+12V</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">-12V</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table></li></ul><h4 id="3-2-MQTT-Client"><a href="#3-2-MQTT-Client" class="headerlink" title="3.2 MQTT Client"></a>3.2 MQTT Client</h4><pre><code class="javascript">var mqtt = require(&#39;mqtt&#39;);//指定服务端地址和端口var client2 = mqtt.connect(&quot;host:1883&quot;);//引入Node.js操作GPIO的库var rpio = require(&#39;rpio&#39;);const player = require(&#39;play-sound&#39;)();rpio.open(12, rpio.OUTPUT);rpio.open(35, rpio.OUTPUT, rpio.HIGH);rpio.open(36, rpio.OUTPUT, rpio.LOW);//MQTT客户端订阅主题train1client2.subscribe(&#39;train1&#39;, { qos: 1 });//订阅主题为train1的消息  //当客户端收到消息时，在控制台输出消息内容，client2.on(&#39;message&#39;, function (top, message) {  //收到验证信息后，验证  rpio.write(11, rpio.HIGH);  rpio.msleep(800)  rpio.write(11, rpio.LOW);  console.log(message.toString() + &#39;号锁已开启！&#39;);  player.play(&#39;./open.mp3&#39;, (err) =&gt; {    if (err) console.log(`Could not play sound: ${err}`);  });  setTimeout(player.play(&#39;./close.mp3&#39;, (err) =&gt; {    if (err) console.log(`Could not play sound: ${err}`);  }), 100000)});</code></pre><ul><li>在<a href="https://www.jianshu.com/p/5cf4df8806c0" target="_blank" rel="noopener">树莓派配置好Node环境</a>，安装MQTT协议的库，订阅相应的主题，在客户端发起对物联网设备的操作请求时，在通过校验后，即可进行相应的操作</li><li>可以根据订阅消息的具体内容再进一步判断操作，但是注意消息内容仅能以字符串形式传递。</li></ul>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>MQTT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Vue和Express的登录注册系统</title>
    <link href="/2020/05/07/%E5%9F%BA%E4%BA%8EVue%E5%92%8CExpress%E7%9A%84%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/05/07/%E5%9F%BA%E4%BA%8EVue%E5%92%8CExpress%E7%9A%84%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>这是一个简单的登录注册示例，包含了登录、注册和用户页面三个部分。本示例的代码保存在我的github仓库，如有不清楚的地方可以下载查阅。<a href="https://github.com/LiuTianjie/LoginSystem" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><h2 id="基于Vue和express的登录注册系统"><a href="#基于Vue和express的登录注册系统" class="headerlink" title="基于Vue和express的登录注册系统"></a>基于Vue和express的登录注册系统</h2><h3 id="1-前端部分"><a href="#1-前端部分" class="headerlink" title="1 前端部分"></a>1 前端部分</h3><h4 id="1-1-UI"><a href="#1-1-UI" class="headerlink" title="1.1 UI"></a>1.1 UI</h4><p>UI方面使用了Element UI的按钮、表单和消息通知等组件。</p><ul><li><p>引入ElementUI</p><pre><code class="shell">vue add element-ui</code></pre></li><li><p>使用ElementUI</p><pre><code class="javascript">//element.jsimport Vue from &#39;vue&#39;import Element from &#39;element-ui&#39;import &#39;element-ui/lib/theme-chalk/index.css&#39;Vue.use(Element)/*这里是全局导入，将ElementUI可用的组件全部挂载到Vue上,这样我们就可以直接使用其组件了，如Vue.prototype.$message等</code></pre></li></ul><h4 id="1-2-网络请求http-js"><a href="#1-2-网络请求http-js" class="headerlink" title="1.2 网络请求http.js"></a>1.2 网络请求http.js</h4><p>前端网络请求使用了axios，通过async—await语法实现异步请求。</p><ul><li><p>引入axios</p><pre><code class="shell">npm install vue-axios</code></pre></li><li><p>配置http.js</p><pre><code class="javascript">import axios from &#39;axios&#39;import Vue from &#39;vue&#39;import router from &#39;./router/index&#39;const http = axios.create({    baseURL: &#39;http://localhost:3030&#39;})//拦截器http.interceptors.request.use((config) =&gt; {    if (localStorage.token) {        config.headers.Authorization = &#39;Bearer &#39; + localStorage.token    }    return config})http.interceptors.response.use(res =&gt; {    return res}, err =&gt; {  //服务器无响应    if (!err.response) {        Vue.prototype.$message.error({            type: &#39;error&#39;,            message: &quot;服务器连接失败&quot;        });        return Promise.reject(err)    }    //服务端返回错误通用处理方案    if (err.response.data.message) {        Vue.prototype.$message.error({            type: &#39;error&#39;,            message: err.response.data.message        });        // console.log(err.response.status)        if (err.response.status === 401) {            router.push(&#39;/login&#39;)        }    }    // console.log(err.response.data.message)    return Promise.reject(err)})export default http</code></pre><p>上述代码进行了如下操作：</p><ul><li><p>配置了请求接口的Baseurl，请求时通过拼接访问具体接口，有利于隐私性。</p></li><li><p>添加了请求拦截器，配合后端的权限机制，在访问需要用户登录后才能使用的页面时，在请求头中添加token，供后端验证。</p></li><li><p>添加了全局错误处理的拦截，配合服务端返回的错误代码和信息，进行相应的展示和跳转，如这里收到服务端401代码则返回登录页面。</p></li><li><p>抛出http模块，在main.js中将其挂载到Vue的原型对象，便于直接通过<strong>this</strong>来使用。</p><pre><code class="javascript">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#39;./plugins/element.js&#39;import router from &#39;./router&#39;import http from &#39;./http&#39;Vue.prototype.$http = httpVue.config.productionTip = falsenew Vue({  router,  render: h =&gt; h(App)}).$mount(&#39;#app&#39;)</code></pre></li></ul></li></ul><h4 id="1-3-前端路由"><a href="#1-3-前端路由" class="headerlink" title="1.3 前端路由"></a>1.3 前端路由</h4><p>使用vue-router实现前端路由。</p><ul><li><p>引入vue-router</p><pre><code class="shell">vue add vue-router --save</code></pre></li><li><p>定义router.js</p><p>本示例中包含3个页面，相应的配置为：</p><pre><code class="javascript">import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;Vue.use(VueRouter)const routes = [  {    path: &#39;/&#39;,    name: &#39;Login&#39;,    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#39;../views/Login.vue&#39;),    meta: { isPublic: true }  },  {    path: &#39;/login&#39;,    name: &#39;Login&#39;,    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#39;../views/Login.vue&#39;),    meta: { isPublic: true }  },  {    path: &#39;/signup&#39;,    name: &#39;SignUp&#39;,    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#39;../views/SignUp.vue&#39;),    meta: { isPublic: true }  },  {    path: &#39;/index:id&#39;,    name: &#39;index&#39;,    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#39;../views/index.vue&#39;),    meta: { isPublic: false }  },  {    path: &#39;*&#39;,    name: &#39;notfound&#39;,    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#39;../views/notfound.vue&#39;)  }]</code></pre><ul><li><p>通过meta属性限定页面是否公开，配合全局导航守卫进行路由判断。</p></li><li><p>通过’*’路由加入404页面。</p></li></ul></li></ul><h5 id="1-3-1-全局导航守卫"><a href="#1-3-1-全局导航守卫" class="headerlink" title="1.3.1 全局导航守卫"></a>1.3.1 全局导航守卫</h5><pre><code class="javascript">router.beforeEach((to, from, next) =&gt; {  if (!to.meta.isPublic &amp;&amp; !localStorage.token) {    Vue.prototype.$message({      type: &quot;warning&quot;,      message: &quot;请先登录&quot;    });    next(&#39;/login&#39;)  }  next()})</code></pre><p>在页面跳转之前进行相应的判断，主要在非法访问页面时跳转到login页面。</p><h4 id="1-4-登录"><a href="#1-4-登录" class="headerlink" title="1.4 登录"></a>1.4 登录</h4><h5 id="1-4-1-Login-vue"><a href="#1-4-1-Login-vue" class="headerlink" title="1.4.1 Login.vue"></a>1.4.1 Login.vue</h5><pre><code class="vue">&lt;script&gt;export default {  name: &quot;app&quot;,  data() {    return {      form: {        account: &quot;&quot;,        psw: &quot;&quot;      }    };  },  components: {},  methods: {    async toLogin() {      if (this.form.psw === &quot;&quot; || this.form.account===&quot;&quot;) {        this.$notify({          title: &quot;输入错误&quot;,          message: &quot;请检查账户和密码！&quot;,          type: &quot;error&quot;        });      } else {        const res = await this.$http.post(&quot;login&quot;, this.form);        localStorage.token = res.data.token;        this.$message({          type: &quot;success&quot;,          message: &quot;登录成功&quot;        });        this.$router.push({ path: `./index${this.form.account}` });      }    },    toSignUp() {      this.$router.push({ path: &quot;./signup&quot; });    }  }};&lt;/script&gt;</code></pre><p>通过定义的toLogin方法进行登录，在前端限制了账户和密码非空，并通过Element的message进行提示。通过POST方法将表单数据。</p><h4 id="1-5-注册"><a href="#1-5-注册" class="headerlink" title="1.5 注册"></a>1.5 注册</h4><h5 id="1-5-1-SignUp-vue"><a href="#1-5-1-SignUp-vue" class="headerlink" title="1.5.1 SignUp.vue"></a>1.5.1 SignUp.vue</h5><pre><code class="vue">&lt;script&gt;export default {  methods: {    toLogin() {      this.$router.push({ path: &quot;./login&quot; });    },    async toSignUp() {      try {        this.loading = true;        const res = await this.$http.post(&quot;/api/users&quot;, this.form);        this.$message({          type: &quot;success&quot;,          message: &quot;注册成功&quot;        });        this.loading = false;      } catch (error) {        this.$message({          type: &quot;error&quot;,          message: &quot;注册失败&quot;        });        this.loading = false;      }      this.clear();    },&lt;/script&gt;</code></pre><h5 id="1-5-2-表单验证"><a href="#1-5-2-表单验证" class="headerlink" title="1.5.2 表单验证"></a>1.5.2 表单验证</h5><pre><code class="javascript">data() {  //验证用户名  var checkAccount = async (rule, value, callback) =&gt; {    if (value === &quot;&quot;) {      this.accountValid = false;      callback(new Error(&quot;账户不能为空&quot;));    } else {      const res = await this.$http.get(`/${this.form.account}`);      if (res.data) {        this.accountValid = false;        callback(new Error(&quot;用户已存在&quot;));      } else {        this.accountValid = true;        callback();      }    }  };  //验证密码1  var checkpsw1 = (rule, value, callback) =&gt; {    if (value === &quot;&quot;) {      this.psw1Valid = false;      callback(new Error(&quot;密码不能为空&quot;));    } else {      if (this.form.psw1 !== &quot;&quot;) {        this.$refs.form.validateField(&quot;psw2&quot;);      }      this.psw1Valid = true;      callback();    }  };  var checkpsw2 = (rule, value, callback) =&gt; {    if (value === &quot;&quot;) {      this.psw2Valid = false;      callback(new Error(&quot;请再次输入密码&quot;));    } else if (value !== this.form.psw1) {      this.psw2Valid = false;      callback(new Error(&quot;两次输入密码不一致!&quot;));    } else {      this.psw2Valid = true;      callback();    }  };  return {    form: {      account: &quot;&quot;,      psw1: &quot;&quot;,      psw2: &quot;&quot;,      check: &quot;&quot;    },    loading: false,    hasRead: false,    accountValid: false,    psw1Valid: false,    psw2Valid: false,    rules: {      account: [{ required: true, validator: checkAccount, trigger: &quot;blur&quot; }],      psw1: [{ required: true, validator: checkpsw1, trigger: &quot;blur&quot; }],      psw2: [{ required: true, validator: checkpsw2, trigger: &quot;blur&quot; }]    }  };},};</code></pre><p>表单验证使用了Element 的表单组件，通过callback函数和rule规则实现。其中触发规则为”blur”。</p><ul><li><p>使用V-model绑定表单的值，通过hasRead等布尔值限制提交。</p></li><li><p>使用了loading组件对注册时的页面进行遮罩。</p></li><li><p>当且仅当5个条件判断的布尔值全部符合条件时，才允许提交注册请求。</p></li><li><p>一次注册成功之后，清除表单数据。</p></li></ul><h3 id="2-后端部分"><a href="#2-后端部分" class="headerlink" title="2 后端部分"></a>2 后端部分</h3><p>后盾的数据库采用MongoDB，通过Node.js的mongoose插件进行数据库的操作。</p><h4 id="2-1登录接口"><a href="#2-1登录接口" class="headerlink" title="2.1登录接口"></a>2.1登录接口</h4><pre><code class="javascript">    //登录接口    app.post(&#39;/login&#39;, async (req, res) =&gt; {        const { account, psw } = req.body        //根据用户名找用户        const user = await User.findOne({ account }).select(&#39;+psw&#39;)        assert(user, 422, &#39;用户不存在&#39;)        //校验密码        const isValid = require(&#39;bcrypt&#39;).compareSync(psw, user.psw)        assert(isValid, 422, &#39;用户名或密码错误&#39;)        //签名返回token        const token = jwt.sign({            _id: user._id,            id: user._id,            username: user.account        }, app.get(&#39;secret&#39;))        res.send({ token })    })</code></pre><p>登录时，通过解构赋值提取Post请求体中的账户和密码。登录验证的步骤如下：</p><ul><li>根据用户名在数据库中查找用户信息，使用assert判断是否查找成功，若查找失败，服务端返回422错误，附带用户不存在的信息。</li><li>成功查找到用户后，使用bcrypt模块生成密码的摘要，与数据库中的摘要进行对比，如果对比失败，则服务端返回422错误，附带账户或密码错误的信息。</li><li>密码验证通过后，使用JSONWebToken进行签名，密钥为定义在服务端的密钥，返回200状态码，并返回token</li></ul><h4 id="2-2-注册接口"><a href="#2-2-注册接口" class="headerlink" title="2.2 注册接口"></a>2.2 注册接口</h4><pre><code class="javascript">router.post(&#39;/&#39;, async (req, res) =&gt; {        assert(req.body.psw1 === req.body.psw2, 422, &#39;两次密码不一致&#39;)        const accountLocal = await User.findOne({ account: req.body.account })        assert(!accountLocal, 502, &quot;用户已存在&quot;)        const model = {}        model.account = req.body.account;        model.psw = req.body.psw1        await req.Model.create(model)        res.send(model)    })</code></pre><p>注册时，除了前端限制，也要在后端进行相应的处理，以避免绕过前端的恶意注册，注册步骤如下：</p><ul><li>检验请求体的两次密码是否一致，不一致则返回422错误，附带两次密码不一致信息</li><li>若两次密码一致，则根据请求体的用户名在数据库进行查找，如果用户已经存在，则返回502错误，附带用户已存在的信息。</li><li>若无误，根据请求体的用户名和密码创建用户，存放到数据库中，其中密码经过bcrypt进行hash，而不是直接存放铭文。</li></ul><h4 id="2-3-用户数据模型"><a href="#2-3-用户数据模型" class="headerlink" title="2.3 用户数据模型"></a>2.3 用户数据模型</h4><pre><code class="javascript">const mongoose = require(&#39;mongoose&#39;)const schema = new mongoose.Schema({    account: { type: String },    psw: {        type: String,        select: false,        set(val) {            return require(&#39;bcrypt&#39;).hashSync(val, 10)        },    }})module.exports = mongoose.model(&#39;User&#39;, schema)</code></pre><p>其中定义psw字段时使用set方法通过bcrypt对密码进行hash签名，生成摘要。用户在数据库中存储的方式为：</p><img src="http://images.nickname4th.vip/用户在数据库中的存储信息.png" srcset="/img/loading.gif" alt="用户在数据库中的存储信息" style="zoom:50%;" /><h4 id="2-4-全局错误处理"><a href="#2-4-全局错误处理" class="headerlink" title="2.4 全局错误处理"></a>2.4 全局错误处理</h4><pre><code class="javascript">app.use(async (err, req, res, next) =&gt; {  res.status(err.statusCode || 500).send({    message: err.message  })})</code></pre><p>配合前端的http拦截器，返回错误信息。</p><h3 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3 中间件"></a>3 中间件</h3><h4 id="3-1-auth-js"><a href="#3-1-auth-js" class="headerlink" title="3.1 auth.js"></a>3.1 auth.js</h4><p>登录成功之后，对应用户访问自己资源的行为需要通过token来鉴定是否具有相应的权限。</p><pre><code class="javascript">//auth.jsmodule.exports = options =&gt; {    const jwt = require(&#39;jsonwebtoken&#39;)    const oUser = require(&#39;../models/User&#39;)    const assert = require(&#39;http-assert&#39;)    return async (req, res, next) =&gt; {        const token = String(req.headers.authorization || &#39;&#39;).split(&#39; &#39;).pop()        assert(token, 401, &#39;登录已过期&#39;)        try {            const { id } = jwt.verify(token, req.app.get(&#39;secret&#39;))            // console.log(id)            assert(id, 401, &#39;账户存在问题！&#39;)            req.user = await oUser.findById(id)            assert(req.user._id, 401, &quot;登录已过期&quot;)        } catch (error) {            return res.status(401).send({ message: &#39;登录已过期&#39; })        }        // console.log(req.user)        await next()    }}</code></pre><p>在具体使用时，如下面的获取用户页面的请求：</p><pre><code class="javascript">const auth = require(&#39;../middle/auth&#39;)//查看个人信息router.get(&#39;/&#39;, auth(), async (req, res) =&gt; {  console.log(&quot;user&quot;, req.user.account)  // const model = await req.Model.findOne({ account: req.user.account })  res.send(req.user.account)})</code></pre><p>通过express的Router，在收到前端GET请求后，先通过CommJS的require语法执行上面auth.js中的代码，进行权限验证。</p><h4 id="3-2-resources-js"><a href="#3-2-resources-js" class="headerlink" title="3.2 resources.js"></a>3.2 resources.js</h4><p>在将来如果有更多的资源，我们可以将接口统一起来，根据前端的需求动态的请求后端的资源，这样更加灵活方便。</p><pre><code class="javascript">//resource.jsmodule.exports = options =&gt; {    return async (req, res, next) =&gt; {        const ModelName = require(&#39;inflection&#39;).classify(req.params.resource)        console.log(req)        req.Model = require(`../models/${ModelName}`)        next()    }}</code></pre><p>通过express的Router，将接口定义为</p><pre><code class="javascript">const resource = require(&#39;../middle/resource&#39;)app.use(&#39;/api/:resource&#39;, resource(), router)</code></pre><p>这样在请求不同资源时，后端就会动态的访问对应的资源，如下面的请求</p><pre><code class="javascript">async getInfo() {  const res = await this.$http.get(&quot;/api/users&quot;);  this.account = res.data;},</code></pre><p>表示获取User的数据。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>express</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CommonJs和ES6模块导入导出</title>
    <link href="/2020/05/05/CommonJs%E5%92%8CES6%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <url>/2020/05/05/CommonJs%E5%92%8CES6%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>学习WebPack工具的一些前端基础，这是web前端系列的第一篇文章。</p><a id="more"></a><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><pre><code class="javascript">//导出//test.js//方式1module.exports = {  name:&#39;module1&#39;,  add: function(a,b){    return a + b  }}//方式2exports.name = &#39;module1&#39;;exports.add = function(a,b){  return a + b}//导入//index.js//方式1const test = require(&#39;./test.js&#39;)const add = test.add//方式2，支持表达式动态导入const modules = [&#39;test.js&#39;,&#39;test2.js&#39;]modules.forEach(name=&gt;{  require(&#39;./&#39;+name)})</code></pre><p>CommonJS注意的地方</p><blockquote><ul><li>在实际使用中，为了提高可读性，建议将module.exports和exports语法语句放在模块最后</li><li>exports指向module.exports，因此不要直接给exports对象赋值，否则会导致module.exports导出失效</li><li>require语句在一个js文件中只<strong>执行一次</strong>，重复使用不会再执行导入模块中的语句</li><li>每个模块都有自己的作用域</li><li>CommonJs导入模块是对其值的拷贝，可以进行修改，不影响原模块</li></ul></blockquote><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><pre><code class="javascript">//导出//test.js//方式1，默认导出，只有一个exportexport dufault {  name:&#39;test&#39;,  add:function(a,b){    return a + b  }}//方式2export const name = &#39;test&#39;export add=function(a,b){  return a+b}//方式3，默认导出const name = &#39;test&#39;add = function(a,b){  return a+b}export {test,add}//方式3，命名导出const name = &#39;test&#39;add = function(a,b){  return a+b}export {test as test1,add as add1}//导入//index.js//方式1，按照原名导入import {name,add} from &#39;./test.js&#39;//方式2，命名导入import {name as name1, add as add1} from &#39;./test.js&#39;//方式3 整体导入import * from &#39;./test.js&#39;//方式4，对默认导出的导入import myModule from &#39;./test.js&#39; //相当于import default as myModule from &#39;./test.js&#39;</code></pre><p>ES6注意的地方</p><blockquote><ul><li>每个模块有自身的作用域</li><li>所有导入的变量都是原模块的动态映射，是只读的，不可以对其进行修改</li><li>对于默认导出来说，导入可以接自定义变量名</li><li>导出、导出必须放在顶层作用域</li></ul></blockquote><h4 id="CommonJS和ES6的区别"><a href="#CommonJS和ES6的区别" class="headerlink" title="CommonJS和ES6的区别"></a>CommonJS和ES6的区别</h4><ul><li>CommonJS对模块依赖的解决是动态的，模块依赖关系的建立发生在代码<strong>运行</strong>阶段。ES6对模块依赖解决的办法是静态的，模块依赖关系的建立发生在代码<strong>编译</strong>阶段</li><li>CommonJS支持导入的路径是表达式，ES6的导入是声明式的，故不支持</li><li>ES6的好处<ul><li>死代码检测和排除</li><li>模块变量类型检查</li><li>编译器优化</li><li>可以利用ES6的特性解决循环依赖问题</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>CommonJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习</title>
    <link href="/2020/04/29/docker_learn/"/>
    <url>/2020/04/29/docker_learn/</url>
    
    <content type="html"><![CDATA[<p>Docker入门的一些基本语法，dockerfile相关的东西待补充。</p><a id="more"></a><h2 id="Docker-CE-on-Ubuntu-18-04"><a href="#Docker-CE-on-Ubuntu-18-04" class="headerlink" title="Docker CE on Ubuntu 18.04"></a>Docker CE on Ubuntu 18.04</h2><h3 id="安装步骤（来自官网）"><a href="#安装步骤（来自官网）" class="headerlink" title="安装步骤（来自官网）"></a>安装步骤（来自官网）</h3><ul><li>完全删除旧的Docker<pre><code class="shell">$ sudo apt-get remove docker docker-engine docker.io containerd runc</code></pre></li><li>升级apt包管理工具<pre><code class="shell">$ sudo apt-get update</code></pre></li><li>安装依赖使apt可以通过https获取包<pre><code class="shell">$ sudo apt-get install \  apt-transport-https \  ca-certificates \  curl \  gnupg-agent \  software-properties-common</code></pre></li><li>获取Docker的GPG密钥并验证<pre><code class="shell">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -$ sudo apt-key fingerprint 0EBFCD88</code></pre></li><li>安装Docker CE<pre><code class="shell">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre><h3 id="惯用配置"><a href="#惯用配置" class="headerlink" title="惯用配置"></a>惯用配置</h3></li><li>将Docker加入用户组<pre><code class="shell">$ sudo adduser $USER docker# 避免每次使用docker命令时必须输入sudo，修改后重新登录shell即可</code></pre></li><li>更换国内镜像源<pre><code class="shell">$ vim /etc/docker/daemon.json{&quot;registry-mirrors&quot;: [&quot;https://vchck76f.mirror.aliyuncs.com&quot;]}# 地址可以去阿里云免费申请</code></pre><h3 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h3></li></ul><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>docker run -it -v [imageID] [hostDir]:[dockerDir]</code></td><td>将宿主机的hostDir文件夹挂载到docker的dockerDir文件夹，如果不存在，将创建</td></tr><tr><td><code>docker run -it -v [imageID] [hostDir]:[dockerDir]:ro</code></td><td>ro即readOnly，使容器只能读取不能写入</td></tr></tbody></table><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>docker ps [-a] [-l]</code></td><td>查看运行中的容器，-a为查看历史所有的容器，-l为上一次运行的容器</td></tr><tr><td><code>docker images</code></td><td>查看docker镜像</td></tr><tr><td><code>docker run [-it] [--name] [imageID] [-d]</code></td><td>使用image创建容器，-i交互模式，-t为容器重新分配伪终端,–name为容器的昵称，-d为守护进程，即后台运行</td></tr><tr><td><code>docker start [name/containerID]</code></td><td>启动名为name或ID为containerID的容器</td></tr><tr><td><code>docker stop [name]</code></td><td>停止名为name或ID为containerID的容器</td></tr><tr><td><code>docker exec [-it] [name/containerID] [/bin/bash]</code></td><td>进入容器，可以指定伪终端的shell路径</td></tr><tr><td><code>docker search [name]</code></td><td>搜索名为name的镜像</td></tr><tr><td><code>docker pull [name]</code></td><td>拉取名为name的镜像到本地</td></tr><tr><td><code>docker rmi [imageID]</code></td><td>删除imageID镜像，删除前必须删除关联的容器</td></tr><tr><td><code>docker rm [name/containerID</code></td><td>删除名为name或ID为containerID的容器，删除前必须停止容器</td></tr><tr><td><code>docker commit [-a=&quot;&quot;] [-m=&quot;&quot;] [containerID] [NewImageName] [tag]</code></td><td>创建名为NewImageName的镜像，-a为作者信息，-m为说明</td></tr></tbody></table><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h3 id="容器持续化"><a href="#容器持续化" class="headerlink" title="容器持续化"></a>容器持续化</h3><h3 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h3><h3 id="Dockercompose"><a href="#Dockercompose" class="headerlink" title="Dockercompose"></a>Dockercompose</h3>]]></content>
    
    
    <categories>
      
      <category>容器技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派搭建NCS2环境并测试</title>
    <link href="/2020/03/05/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BANCS2%E7%8E%AF%E5%A2%83%E5%B9%B6%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/03/05/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BANCS2%E7%8E%AF%E5%A2%83%E5%B9%B6%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>做毕设和一些实验的基础，在树莓派环境搭建NCS2的依赖环境并进行相关测试</p><a id="more"></a><h3 id="OpenVINO-toolkit-for-RaspberryPi-树莓派NCS2环境搭建"><a href="#OpenVINO-toolkit-for-RaspberryPi-树莓派NCS2环境搭建" class="headerlink" title="OpenVINO toolkit for RaspberryPi(树莓派NCS2环境搭建)"></a>OpenVINO toolkit for RaspberryPi(树莓派NCS2环境搭建)</h3><p>@Nickname4th 2019/10/01</p><p>Call me at: 1733****598</p><h3 id="烧写官方镜像"><a href="#烧写官方镜像" class="headerlink" title="烧写官方镜像"></a>烧写官方镜像</h3><ul><li>使用BleanEtchar，略</li></ul><h3 id="TensorFlow配置"><a href="#TensorFlow配置" class="headerlink" title="TensorFlow配置"></a>TensorFlow配置</h3><h4 id="更换apt和pip源"><a href="#更换apt和pip源" class="headerlink" title="更换apt和pip源"></a>更换apt和pip源</h4><pre><code class="shell">sudo vim /etc/apt/sources.list</code></pre><blockquote><p>注释原来的源，添加 </p><p>deb <a href="http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a> stretch main contrib non-free rpi<br>deb-src <a href="http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a> stretch main contrib non-free rpi</p></blockquote><pre><code class="shell">pip install pippip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</code></pre><h4 id="安装matplot-使用VNC调试更直观，后续可注释相关代码并以CLI启动"><a href="#安装matplot-使用VNC调试更直观，后续可注释相关代码并以CLI启动" class="headerlink" title="安装matplot(使用VNC调试更直观，后续可注释相关代码并以CLI启动)"></a>安装matplot(使用VNC调试更直观，后续可注释相关代码并以CLI启动)</h4><pre><code class="shell">sudo pip3 install matplotlib</code></pre><h4 id="安装TensorFlow"><a href="#安装TensorFlow" class="headerlink" title="安装TensorFlow"></a>安装TensorFlow</h4><pre><code class="shell">sudo pip3 install tensorflow</code></pre><blockquote><p>安装依赖包时出现报错时将报错的依赖包单独使用sudo pip3 install [包名]即可</p></blockquote><ul><li>安装第三方whl</li></ul><blockquote><p>集成了TensorFlow的api，可以快速测试一个模型</p><pre><code class="shell">sudo pip3 install obapi-1.0.0-py3-none-any.whl</code></pre><p>感谢作者@obapi</p></blockquote><ul><li><p>根据代码移入模型相关文件夹和TensorFlow相关文件夹并修改路径</p><blockquote><p>这里主要是object_detection和silm文件夹等</p></blockquote></li></ul><h4 id="安装opencv及其依赖"><a href="#安装opencv及其依赖" class="headerlink" title="安装opencv及其依赖"></a>安装opencv及其依赖</h4><pre><code class="shell">sudo pip3 install opencv-pythonsudo apt-get install libcblas-devsudo apt-get install libhdf5-devsudo apt-get install libhdf5-serial-devsudo apt-get install libatlas-base-devsudo apt-get install libjasper-dev sudo apt-get install libqtgui4 sudo apt-get install libqt4-test</code></pre><blockquote><p>由于树莓派官方系统更新，可能会因为依赖冲突发生多次错误，耐心按照apt的报错决定是否覆盖安装相关依赖包</p></blockquote><h3 id="TensorFlow模型转换及前后性能测试"><a href="#TensorFlow模型转换及前后性能测试" class="headerlink" title="TensorFlow模型转换及前后性能测试"></a>TensorFlow模型转换及前后性能测试</h3><ul><li><p><a href="https://software.intel.com/en-us/openvino-toolkit/choose-download/free-download-macos" target="_blank" rel="noopener">下载最新版本的macOS*的工具箱OpenVINO toolkit</a>，记住激活码</p></li><li><p>按照<a href="https://docs.openvinotoolkit.org/latest/_docs_install_guides_installing_openvino_macos.html" target="_blank" rel="noopener">官网说明</a>进行配置</p></li><li><p>本次使用冻结模型ssdlite_mobilenet_v2_coco_2018_05_09(官网发现他正好是受支持的拓扑结构)</p></li><li><p>下载模型，将其转换成IR中间件表示</p><ul><li><a href="http://download.tensorflow.org/models/object_detection/ssdlite_mobilenet_v2_coco_2018_05_09.tar.gz" target="_blank" rel="noopener">下载传送门</a></li><li>开始模型转换，<a href="https://docs.openvinotoolkit.org/latest/_docs_MO_DG_prepare_model_convert_model_Convert_Model_From_TensorFlow.html" target="_blank" rel="noopener">转换指南</a></li><li>得到.xml和.bin文件</li><li>修改程序进行对比</li></ul></li></ul><h4 id="TestWithOutNCS2-py"><a href="#TestWithOutNCS2-py" class="headerlink" title="TestWithOutNCS2.py"></a>TestWithOutNCS2.py</h4><blockquote><p>这里就是之前在导盲杖和MacBook Pro上跑的目标检测算法</p></blockquote><pre><code class="python">import numpy as npimport sysimport tensorflow as tffrom obapi import label_map_utilfrom obapi import visualization_utils as vis_utilfrom PIL import Image# import matplotlib.pyplot as pltimport timesys.path.append(&#39;/home/pi/NCS2/object_detection&#39;) # point to your tensorflow dirsys.path.append(&#39;/home/pi/NCS2/slim&#39;) # point ot your slim dir# What model to download.MODEL_NAME = &#39;/home/pi/NCS2/object_detection/&#39;PATH_TO_CKPT = MODEL_NAME + &#39;/frozen_inference_graph.pb&#39;PATH_TO_LABELS = &#39;/home/pi/NCS2/obj/data/mscoco_label_map.pbtxt&#39;NUM_CLASSES = 90detection_graph = tf.Graph()with detection_graph.as_default():  od_graph_def = tf.GraphDef()  with tf.gfile.GFile(PATH_TO_CKPT, &#39;rb&#39;) as fid:    serialized_graph = fid.read()    od_graph_def.ParseFromString(serialized_graph)    tf.import_graph_def(od_graph_def, name=&#39;&#39;)#Loading label maplabel_map = label_map_util.load_labelmap(PATH_TO_LABELS)categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=True)category_index = label_map_util.create_category_index(categories)#Helper codedef load_image_into_numpy_array(image):  (im_width, im_height) = image.size  return np.array(image.getdata()).reshape(      (im_height, im_width, 3)).astype(np.uint8)TEST_IMAGE_PATHS = [&#39;/home/pi/NCS2/obj/test_images/1.jpg&#39;]# Size, in inches, of the output images.IMAGE_SIZE = (16, 9)with detection_graph.as_default():  with tf.Session(graph=detection_graph) as sess:    image_tensor = detection_graph.get_tensor_by_name(&#39;image_tensor:0&#39;)    detection_boxes = detection_graph.get_tensor_by_name(&#39;detection_boxes:0&#39;)    detection_scores = detection_graph.get_tensor_by_name(&#39;detection_scores:0&#39;)    detection_classes = detection_graph.get_tensor_by_name(&#39;detection_classes:0&#39;)    num_detections = detection_graph.get_tensor_by_name(&#39;num_detections:0&#39;)    import cv2    while 1:        for image_path in TEST_IMAGE_PATHS:            start = time.clock()            cap = cv2.VideoCapture(0)            ret, frame = cap.read()            cv2.imwrite(&quot;/home/pi/NCS2/obj/test_images/1.jpg&quot;, frame)            cap.release()            image = Image.open(image_path)            image_np = load_image_into_numpy_array(image)            image_np_expanded = np.expand_dims(image_np, axis=0)            image_tensor = detection_graph.get_tensor_by_name(&#39;image_tensor:0&#39;)            boxes = detection_graph.get_tensor_by_name(&#39;detection_boxes:0&#39;)            scores = detection_graph.get_tensor_by_name(&#39;detection_scores:0&#39;)            classes = detection_graph.get_tensor_by_name(&#39;detection_classes:0&#39;)            num_detections = detection_graph.get_tensor_by_name(&#39;num_detections:0&#39;)            # Actual detection.            (boxes, scores, classes, num_detections) = sess.run(                [boxes, scores, classes, num_detections],                feed_dict={image_tensor: image_np_expanded})            # Visualization of the results of a detection.            vis_util.visualize_boxes_and_labels_on_image_array(                image_np,                np.squeeze(boxes),                np.squeeze(classes).astype(np.int32),                np.squeeze(scores),                category_index,                use_normalized_coordinates=True,                line_thickness=8)            a = np.squeeze(classes).astype(np.int32)[0]            elapsed = (time.clock() - start)            name = category_index[a][&#39;name&#39;]            print(&quot;This is a &quot;,name)            print(&quot;Time used:&quot;,elapsed)            # plt.figure(figsize=IMAGE_SIZE)            # plt.imshow(image_np)            # plt.show()</code></pre><ul><li>冷启动时间：20.6s</li><li>单独进行一次图像识别时间：6.03s</li></ul><h4 id="TestWithNCS2-py"><a href="#TestWithNCS2-py" class="headerlink" title="TestWithNCS2.py"></a>TestWithNCS2.py</h4><blockquote><p>这里是将原来的目标检测算法转换后，通过计算棒执行的目标检测</p></blockquote><pre><code class="shell">cd object_detection-masterpython3 main.py -d MYRIAD -i &quot;cam&quot; -m &quot;ssd_v2.xml&quot; # 使用摄像头进行实时目标检测 python3 main.py  -d MYRIAD -i &quot;Cars - 1900.mp4&quot; -m &quot;./mobilenet-ssd/FP32/mobilenet-ssd.xml&quot; # 在测试视频中运行目标检测</code></pre><blockquote><p>注意：通过ssh进行目标检测时，会由于无法调用display而报错，这里将cv2.imshow()注释即可，如果要观测，可以通过VNC连接至树莓派，通过内置终端执行语句</p><p>object_detection-master文件夹资源链接：<a href="https://yaleedupl-my.sharepoint.com/:f:/g/personal/acs_shier_love/Eu6GMrDyxi9DkFD4rAKy6-ABjpyvwmHuBWWkQRijtCo4rQ?e=zr7eIA" target="_blank" rel="noopener">https://yaleedupl-my.sharepoint.com/:f:/g/personal/acs_shier_love/Eu6GMrDyxi9DkFD4rAKy6-ABjpyvwmHuBWWkQRijtCo4rQ?e=zr7eIA</a></p></blockquote><pre><code class="python">#main.py代码from __future__ import print_functionimport sysimport osfrom argparse import ArgumentParserimport cv2import timeimport logging as logimport numpy as npimport ioimport detect as dtfrom openvino.inference_engine import IENetwork, IEPluginfrom pathlib import Pathsys.path.insert(0, str(Path().resolve().parent.parent))def build_argparser():    parser = ArgumentParser()    parser.add_argument(&quot;-m&quot;, &quot;--model&quot;, help=&quot;Path to an .xml file with a trained model.&quot;, required=True, type=str)    parser.add_argument(&quot;-i&quot;, &quot;--input&quot;,                        help=&quot;Path to video file or image. &#39;cam&#39; for capturing video stream from camera&quot;,                        type=str)    parser.add_argument(&quot;-l&quot;, &quot;--cpu_extension&quot;,                        help=&quot;MKLDNN (CPU)-targeted custom layers.Absolute path to a shared library with the kernels &quot;                             &quot;impl.&quot;, type=str, default=None)    parser.add_argument(&quot;-pp&quot;, &quot;--plugin_dir&quot;, help=&quot;Path to a plugin folder&quot;, type=str, default=None)    parser.add_argument(&quot;-d&quot;, &quot;--device&quot;,                        help=&quot;Specify the target device to infer on; CPU, GPU, FPGA, MYRIAD or HDDL is acceptable. Sample &quot;                             &quot;will look for a suitable plugin for device specified (CPU by default)&quot;, default=&quot;CPU&quot;,                        type=str)    parser.add_argument(&quot;--labels&quot;, help=&quot;Labels mapping file&quot;, default=None, type=str)    parser.add_argument(&quot;-pt&quot;, &quot;--prob_threshold&quot;, help=&quot;Probability threshold for detections filtering&quot;,                        default=0.5, type=float)    parser.add_argument(&quot;-o&quot;, &quot;--output_dir&quot;, help=&quot;If set, it will write a video here instead of displaying it&quot;,                        default=None, type=str)    return parserdef make_sure_path_exists(path):    try:        os.makedirs(path)    except OSError as exception:        passdef main():    is_async_mode = True    args = build_argparser().parse_args()    object_detection=dt.Detectors(args.device,args.model,args.cpu_extension,args.plugin_dir,is_async_mode)    resultant_initialisation_object=object_detection.initialise_inference()    input_stream = args.input    cap = cv2.VideoCapture(0)    ret, frame = cap.read()    cv2.imwrite(&quot;/home/pi/NCS2/obj/test_images/1.jpg&quot;, frame)    video_len = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))    frame_width = int(cap.get(3))    frame_height = int(cap.get(4))    cur_request_id = 0    next_request_id = 1    try:        while cap.isOpened():            start = time.clock()            ret, frame = cap.read()            if not ret:                break            initial_w = cap.get(3)            initial_h = cap.get(4)            res_inference=resultant_initialisation_object.process_frame(cur_request_id,next_request_id,frame,initial_h,initial_w,False)            resultant_frame=resultant_initialisation_object.placeBoxes(res_inference,None,0.5,frame,initial_w,initial_h,False,cur_request_id)            key = cv2.waitKey(1)            if key == 27:                break            elapsed = (time.clock() - start)            print(&quot;Time used:&quot;,elapsed)        cap.release()    finally:        del resultant_initialisation_object.exec_netif __name__ == &#39;__main__&#39;:    sys.exit(main() or 0)</code></pre><ul><li>冷启动时间：2.0s</li><li>单独进行一次图像识别时间：0.06s</li></ul><h3 id="RealTime的性能对比"><a href="#RealTime的性能对比" class="headerlink" title="RealTime的性能对比"></a>RealTime的性能对比</h3><blockquote><p>相同场景下实时识别，对比帧数</p></blockquote><p>待续。。。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NCS2</tag>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨年旅行计划</title>
    <link href="/2019/12/06/%E8%B7%A8%E5%B9%B4%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2019/12/06/%E8%B7%A8%E5%B9%B4%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>2019-2020跨年旅行计划，实际过程略有差别。</p><a id="more"></a><h2 id="旅行规划"><a href="#旅行规划" class="headerlink" title="旅行规划"></a>旅行规划</h2><blockquote><p>@Nickname4th @是这个zhang馨</p></blockquote><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li>📅2019年12月27日-2020年1月1日<ul><li>2019年12月28日凌晨01:30分小仙女🧚‍♀️抵达美兰机场✈️</li><li>2020年1月1日晚上23:30分一起回家</li></ul></li></ul><h4 id="物资筹备"><a href="#物资筹备" class="headerlink" title="物资筹备"></a>物资筹备</h4><ul><li>穿<ul><li>可爱的小裙裙裙👗</li><li>可爱或酷的鞋👢</li><li>御寒的外套🧥</li><li>游泳的👙</li><li>私人物品</li></ul></li><li>旅行用品<ul><li>Canon M6📷</li><li>iPhone 11 📱</li><li>学生证👩‍🎓👨‍🎓</li><li>非常规必备化妆系列<ul><li>防晒霜🧴</li><li>补水💦</li></ul></li><li>Money💰</li></ul></li><li>为了回家<ul><li>羽绒服</li><li>围巾🧣</li><li>等防寒物品</li></ul></li></ul><h4 id="路线和时间"><a href="#路线和时间" class="headerlink" title="路线和时间"></a>路线和时间</h4><table><thead><tr><th align="center">时间</th><th align="center">地点</th><th align="center">项目</th></tr></thead><tbody><tr><td align="center">12.28</td><td align="center">观澜湖冯小刚电影公社、蜡像馆</td><td align="center"></td></tr><tr><td align="center">12.29</td><td align="center">南山寺、天涯海角、鹿回头</td><td align="center"></td></tr><tr><td align="center">12.30</td><td align="center">蜈支洲岛、椰梦长廊</td><td align="center"></td></tr><tr><td align="center">12.31</td><td align="center">亚龙湾天堂森林公园、玻璃栈道、玫瑰谷森林公园</td><td align="center"></td></tr></tbody></table><ul><li>12.28 海口 观澜湖华谊冯小刚电影公社🎬     观澜湖矿物质温泉主题公园⛲️<ul><li>海口东站——观澜湖<ul><li>1942民国街</li><li>南洋街</li><li>芳华小院</li><li>海洋馆🐬</li><li>名人蜡像馆</li><li>温泉♨️</li></ul></li><li>傍晚：海口东站——三亚🚄</li><li>住：三亚湾（待定）</li></ul></li><li>12.29 三亚 三亚湾<ul><li>南山寺<ul><li>南海观音</li></ul></li><li>鹿回头🦌</li><li>天涯海角</li></ul></li><li>12.30 三亚 亚龙湾<ul><li>亚龙湾热带天堂森林公园<ul><li>玻璃栈道</li><li>环游</li></ul></li><li>玫瑰谷森林公园</li><li>三亚千古情</li></ul></li><li>12.31 三亚 蜈支洲岛 <ul><li>槟榔谷</li><li>五指山漂流</li><li>凤凰岛酒店天空酒廊（待定）</li></ul></li><li>1.1海口 小刘的大学生活体验🏫<ul><li>海口东站——海南大学<ul><li>南门第一家清补凉🥗</li><li>校车🚌参观小刘平时呆的地方</li></ul></li><li>美兰机场✈️——成都双流</li></ul></li></ul><h4 id="Something"><a href="#Something" class="headerlink" title="Something"></a>Something</h4><ul><li><input disabled="" type="checkbox"> 在某个海边或高处🏖看日落</li><li><input checked="" disabled="" type="checkbox"> 一起吹吹风</li><li><input disabled="" type="checkbox"> 拍一张落日时分的剪影</li><li><input checked="" disabled="" type="checkbox"> 在某个海鲜市场寻找小张心心念的螃蟹🦀</li><li><input disabled="" type="checkbox"> 带上漂流瓶许一个愿望</li></ul><h4 id="预算和经费"><a href="#预算和经费" class="headerlink" title="预算和经费"></a>预算和经费</h4><ul><li><p>机票🛫</p><ul><li>小张来回 ￥2240</li><li>小刘回     ￥800</li></ul></li><li><p>车马费🐴</p></li></ul><ul><li><p>吃喝玩乐🍲</p></li><li><p>住宿🏡</p></li><li><p>纪念品🎁</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>个人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
      <tag>纪念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
